<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MixFlow「混流」| A programmer and CG artist&#39;s personal website</title>
  
  <subtitle>Programmming CG UE4 Blender PBR</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mix-flow.com/"/>
  <updated>2018-05-30T11:57:10.076Z</updated>
  <id>http://www.mix-flow.com/</id>
  
  <author>
    <name>Mix Flow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Blender Cycles 室内作品</title>
    <link href="http://www.mix-flow.com/2018/05/29/blender-cycles-interior/"/>
    <id>http://www.mix-flow.com/2018/05/29/blender-cycles-interior/</id>
    <published>2018-05-29T05:25:54.000Z</published>
    <updated>2018-05-30T11:57:10.076Z</updated>
    
    <content type="html"><![CDATA[<p>本人制作 3D 室内渲染作品，参考他人室内设计的<a href="https://www.behance.net/gallery/55050865/PartiDesign-CHT-Architect-CHEF-AND-CATS" target="_blank" rel="noopener">照片 PartiDesign &amp; CHT Architect|CHEF AND CATS</a>。 在Blender制作并还原。</p><p>使用的 Blender 2.79 版本，Cycles 渲染器。直接看结果如下 参照照片 以及 渲染结果：</p><div class="figure"><img src="/images/util/loading.gif" alt="参照室内设计的照片" class="b-lazy" data-src="https://mir-s3-cdn-cf.behance.net/project_modules/1400/1a570d55050865.5974e1118c9f7.jpg"><p class="caption">参照室内设计的照片</p></div><div class="figure"><img src="/images/util/loading.gif" alt="我的作品渲染结果" class="b-lazy" data-src="/images/2018-interior/result-1.jpg"><p class="caption">我的作品渲染结果</p></div><p>接触 Blender 有段时间了，但是由于不是专门做 Blender CG，所以也没有多少作品可供展示。 最近想要 stress test 一下 CG 方面能力，自检下实力。</p><a id="more"></a><p>选择的是现实的室内场景，感觉比较合适，原因如下：</p><ul><li>本人非设计出身，自己自由发挥的话，不一定美观。所以参考专业建筑师设计的美观房间。</li><li>因为不再是新人了，测试实力，需要有一定工作量，相较与之前做的 <a href="/2017/04/01/blender-cycles-render-donuts/" title="面包圈">面包圈</a>，不再是局部。</li><li>工作量可控，不会过量，一方面 ray trace 3D render 太耗时，另一方面3D Artist也不是我主要目标。</li></ul><p>由于将来本人需要进行复杂的建模，所有建模都是从零亲自建模的，没有使用 props 素材。</p><p>其中一个难点是<code>Sculpt</code>，如名即雕刻，之前没怎么接触过。用来做布料的褶皱之类的，想做逼真的沙发以及枕头，就需要用到。</p><div class="figure"><img src="/images/util/loading.gif" alt="Couch" class="b-lazy" data-src="/images/2018-interior/result-2.jpg"><p class="caption">Couch</p></div><p>另外 Blender 2.79 内置 <code>filmic</code>，不过不是默认启用的，需要自己去color management里选。 关于 filmic 详细介绍我的另一篇文章 <a href="/2017/08/26/The-Secret-Ingredient-to-Photorealism/" title="照片级现实的秘密">照片级现实的秘密</a> 中有介绍。 只是新版本 Blender 不再需要额外装插件了。</p><div class="figure"><img src="/images/util/loading.gif" alt="书架 懒人沙发" class="b-lazy" data-src="/images/2018-interior/result-3.jpg"><p class="caption">书架 懒人沙发</p></div><p>另外我实际参考了<a href="https://www.youtube.com/watch?v=EmqEP2-UvAY&amp;t=1209s" target="_blank" rel="noopener">u2b CG Geek 教程</a>， 参考的室内场景即教程中参考的，但不是step by step跟着做，而是为了看下专业人士的制作细节，以便改进。 下面就说下难点，以及我从 CG Geek 学到的技巧。</p><ol style="list-style-type: decimal"><li>首当其冲的，就是把照片作为背景，并且还原相机的位置角度，然后开始建模，类似于临摹，这样你的房间物体比例不会失调。 CG Geek的做法是目测，我不推荐。首先这需要很多经验才能手动调准， 另外即使经验老道也会经常不准，实际上教程中后他也意识到有些物品位置冲突，当然误差不是大到严重影响。 我推荐使用 <code>BLAM 插件</code><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>，只要对着照片画平行于x y轴各两条线，自动帮你校准相机。</li><li>善用 <code>pivot center</code> 以及 <code>proportional edit mode</code>。这两个在编辑物品 <code>位置 location</code>/<code>比例 scale</code>/<code>旋转 rotation</code> 非常有用，尤其一些复杂的操作，参考教程中做茶几桌腿，如何卷曲电视机和书封的部分</li><li><code>edit mode</code>模式下，关联选择<code>link select</code>（快捷键<code>L</code>），在一个<code>object</code>有多个部件时非常有用，能让你单独选中部件。</li><li>CG Geek有个习惯让我有了新的认识，就是一个物体的各个不同部件能在<code>edit mode</code>里面放到一起就放到一起， 可以用<code>split</code>分割部件（快捷键<code>Y</code>），可以结合上一条可以快捷准确选择部件。</li><li>关于上一条，CG Geek有时一个<code>object</code>中放的东西过多，例如他做墙面的时候，4面墙都是放在一个<code>object</code>，如果你只是做 CG 3D 那无所谓。 如果你是建模将来准备用在游戏中，</li><li>这一条我自己总结的，CG Geek也没养成这个好习惯：建模后，如果要 曲面细分<code>subdivision surface</code> 或者 多维解析<code>multiresolution</code>，在这之前一定要先 <code>Unwrap UV mapping</code>。 如果你提高了模型的精度并应用后，再<code>Unwrap UV mapping</code>你面对的是超多数量的面。 尤其还需要做了<code>sculpt</code>，例如枕头这种的，一个在最前面做<code>UV</code>。</li></ol><div class="footnotes"><hr><ol><li id="fn1"><p>BLAM插件链接: https://github.com/stuffmatic/blam<a href="#fnref1">↩</a></p></li></ol></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人制作 3D 室内渲染作品，参考他人室内设计的&lt;a href=&quot;https://www.behance.net/gallery/55050865/PartiDesign-CHT-Architect-CHEF-AND-CATS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;照片 PartiDesign &amp;amp; CHT Architect|CHEF AND CATS&lt;/a&gt;。 在Blender制作并还原。&lt;/p&gt;
&lt;p&gt;使用的 Blender 2.79 版本，Cycles 渲染器。直接看结果如下 参照照片 以及 渲染结果：&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;/images/util/loading.gif&quot; alt=&quot;参照室内设计的照片&quot; class=&quot;b-lazy&quot; data-src=&quot;https://mir-s3-cdn-cf.behance.net/project_modules/1400/1a570d55050865.5974e1118c9f7.jpg&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;参照室内设计的照片&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;/images/util/loading.gif&quot; alt=&quot;我的作品渲染结果&quot; class=&quot;b-lazy&quot; data-src=&quot;/images/2018-interior/result-1.jpg&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;我的作品渲染结果&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;接触 Blender 有段时间了，但是由于不是专门做 Blender CG，所以也没有多少作品可供展示。 最近想要 stress test 一下 CG 方面能力，自检下实力。&lt;/p&gt;
    
    </summary>
    
      <category term="my work" scheme="http://www.mix-flow.com/categories/my-work/"/>
    
      <category term="blender" scheme="http://www.mix-flow.com/categories/my-work/blender/"/>
    
      <category term="cycles" scheme="http://www.mix-flow.com/categories/my-work/blender/cycles/"/>
    
    
      <category term="CG" scheme="http://www.mix-flow.com/tags/CG/"/>
    
      <category term="interior" scheme="http://www.mix-flow.com/tags/interior/"/>
    
      <category term="blender" scheme="http://www.mix-flow.com/tags/blender/"/>
    
      <category term="PBR" scheme="http://www.mix-flow.com/tags/PBR/"/>
    
      <category term="3D" scheme="http://www.mix-flow.com/tags/3D/"/>
    
      <category term="cycles" scheme="http://www.mix-flow.com/tags/cycles/"/>
    
      <category term="render" scheme="http://www.mix-flow.com/tags/render/"/>
    
      <category term="filmic" scheme="http://www.mix-flow.com/tags/filmic/"/>
    
  </entry>
  
  <entry>
    <title>照片级写实的秘诀 The Secret Ingredient to Photorealism</title>
    <link href="http://www.mix-flow.com/2017/08/26/The-Secret-Ingredient-to-Photorealism/"/>
    <id>http://www.mix-flow.com/2017/08/26/The-Secret-Ingredient-to-Photorealism/</id>
    <published>2017-08-26T13:33:47.000Z</published>
    <updated>2017-10-01T11:37:52.149Z</updated>
    
    <content type="html"><![CDATA[<p>我曾经在我的文章 <a href="/2017/04/01/blender-cycles-render-donuts/" title="Blender Cycles渲染作品 面包圈">Blender Cycles渲染作品 面包圈</a> 提到发现一个改进方法，能够大幅提高渲染 <em>render</em> 效果。</p><p>本文我会通过上面提及的面包圈作品作为实例，来谈论原生blender <code>dynamic range 动态范围</code>的限制。 以及突破限制的方式，即<code>Filmic Blender</code>插件，最终能带来不可思议的照片级渲染效果。</p><div class="figure"><img src="/images/2017-BlenderFilmic/filmic-before&amp;after.jpg" alt="渲染效果对比 右边改进的作品 提升效果明显"><p class="caption">渲染效果对比 右边改进的作品 提升效果明显</p></div><p>这个改进方法我是从blenderguru的一个非常棒的<a href="https://youtu.be/m9AT7H4GGrA" target="_blank" rel="noopener">教程视频 The Secret Ingredient to Photorealism</a>学到的。 如果英语还行并且能上U2B，我极力推荐观看。我文章基本就是根据视频整理得出，额外加些我的内容。</p><p>另外本文基于blender编写，但是里面相当多的内容并不局限于blender，甚至<code>Filmic</code>的幕后实现也是基于其他领域的成果（下面正文<!-- TODO link to the section-->我会介绍）。 所以如果你使用其他CG或者渲染软件，以及别的相关领域也建议了解下。 <a id="more"></a> 比如虚幻4 UE4游戏引擎在4.15版本的时候也有类似的新特性 <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>。</p><h2 id="what-is-dynamic-range">What is Dynamic Range</h2><p>首先从拍照来引入，相机（或手机）取景会显得过亮或者过暗，我们经常会选取图像的某一处作为“曝光点”， 然后镜头会以我们选择的“曝光点”作为 中间灰度值 <em>middle grey</em> 自动调节。</p><p>在一些光照复杂的情况，比如烈日户外，我需要拍摄一个阴影处的物体，我们选择暗处作为曝光点， 可能外部天空背景就会显得过亮。当我选择天空作为曝光点，暗处又会显得很暗，甚至一团黑完全看不到东西。</p><p>这两种纠结的情况会发生，就是因为相机曝光范围有限制，这个限制范围就是 <code>dynamic range 动态范围</code> 。</p><div class="figure"><img src="" alt="Dynamic Range. 图片来源blenderguru.com" class="b-lazy" data-src="/images/2017-BlenderFilmic/dynamic-range.png"><p class="caption">Dynamic Range. 图片来源blenderguru.com</p></div><p>超出 <code>dynamic range</code> 的部分被称为 <code>clipping</code> ，过暗以至于完全黑色的被称作 <code>black clipping</code> ， 相反的过亮完全变白的的被称作 <code>white clipping</code> 。</p><div class="figure"><img src="" alt="Clipping 下图红色部分即 white clipping 部分(高光)， 另外图中黑色冲压（图中间的柱体）也有 black clipping 的部分 图片来源 wikipedia" class="b-lazy" data-src="https://upload.wikimedia.org/wikipedia/commons/7/7b/Blown-out_highlights.jpg"><p class="caption"><strong><code>Clipping</code></strong> 下图红色部分即 <code>white clipping</code> 部分(高光)， 另外图中黑色冲压（图中间的柱体）也有 <code>black clipping</code> 的部分 图片来源 <a href="https://en.wikipedia.org/wiki/Clipping_(photography)" target="_blank" rel="noopener">wikipedia</a></p></div><p><code>clipping</code> 的部分是超出了感光器材的 <code>dynamic range</code> 产生，但并不是所有情况都是缺陷。有些情况下， 有些地方就因该是高光，比如光滑金属的反光的部分；或者完全的暗部，现实光照就是不足以照亮的角落 。但有时不能接受， 比如我的面包圈之前的效果，其中一处在偏左白色盘子存在 <code>white clipping</code> 问题， 以至无法看出盘子中间是凹的（对比右图）。</p><p>笼统说 <code>dynamic range</code> 越宽，效果越好。衡量其范围的单位为 <code>f-stops</code>:</p><div class="figure"><img src="" alt="不同的成像设备以及人眼的f-stops。 图片来源blenderguru.com" class="b-lazy" data-src="/images/2017-BlenderFilmic/f-stops.png"><p class="caption">不同的成像设备以及人眼的f-stops。 图片来源blenderguru.com</p></div><p>上述图中，最好的是人眼，达到了 <code>20 f-stops</code>。最差的便携相机都有 <code>10 f-stops</code>。 而blender，仅有 <code>8 f-stops</code>，甚至连最差的便携相机都不如。</p><h2 id="dynamic-range-如何影响渲染结果">Dynamic Range 如何影响渲染结果</h2><p>前文一直借用摄像领域的介绍，现在回到blender，谈谈 <code>dynamic range</code> 如何影响渲染的结果。</p><div class="figure"><img src="" alt="左边盘子已经出现 white clipping 但是整个场景很多依旧感觉很暗" class="b-lazy" data-src="/images/2017-BlenderFilmic/sRGB_camera_0.png"><p class="caption">左边盘子已经出现 <code>white clipping</code> 但是整个场景很多依旧感觉很暗</p></div><p>在左边盘子以及桌面出现大量的 <code>white clipping</code> 的时候， 光源不能继续提高亮度了，但是场景有的部分依旧感觉很暗，比如右边 巧克力面包圈下面的阴影。</p><blockquote><p>blenderguru的教程，其使用的例子也是类似的情况，而且其光照条件更为苛刻。 是在一个基本封闭的室内，只有一扇窗户有采光，当透过这扇窗的直射光找到 其室内的桌子并出现 <code>white clipping</code> 的时候，整个房间别处依旧很暗。 而这间房子，即作者的房间，作者提供一张现实的照片，现实里并不会如此暗， 整个房间还是很明亮的。</p></blockquote><p>这时，有些人会采取一些“作弊”方式来解决，比如添加额外的光源来模拟增强反射光<code>bounce lighting</code>， 或者增强 <code>sky light</code> 来增加室内光线。</p><p>但仔细想想 <strong>这种做法没有意义！</strong> 我们现实世界并不需要“作弊”。</p><p>Blender存在这些问题是由于狭窄的 <code>dynamic range</code> 限制:</p><ul><li>场景过暗，是由于光源的反射光不足。</li><li>光源的反射光不足，是由于光源亮度不够。</li><li>光源的亮度不够，是由于光源已经很刺眼了。</li><li>光源完全刺眼，是由于 <code>dynamic range</code> 太窄只有 <code>8 f-stops</code>。</li></ul><p>如果我们能够提高 <code>dynamic range</code>，我们就可以提高光源亮度，这样反射光就会增强， 最终我们就能得到完美的光照效果，而不需要额外的工作量。</p><h2 id="blender-dynamic-range-有限的原因">Blender Dynamic Range 有限的原因</h2><p>幸运的是blender的<code>渲染器 renderer</code> 并不存在缺陷，别的 <code>renderer</code> 也有可能出现该问题。 真正问题根源是原生blender使用的 <code>色彩管理配置 Color Management Configuration</code>。</p><p><code>renderer</code> 和相机，存储图像数据都是数字格式，当将数字数据显示为图像的时候，是 需要经过转化处理的，就是 <code>色彩转化 color transform</code>。</p><p><strong>问题的根源</strong> 是blender使用了 <strong><code>sRGB</code></strong> color transform。<code>sRGB</code> 是设计来模拟 CRT显示器 的显示效果。 而这本意不是用来渲染的，永远不应该拿来渲染。</p><h2 id="解决方式-filimic-blender">解决方式 Filimic Blender</h2><p>我们只需要将原生的blender的<code>sRGB</code> 改为名为 <code>Filmic Blender</code> 的 <code>color management</code>。</p><p><a href="https://sobotka.github.io/filmic-blender/" target="_blank" rel="noopener">Filmic Blender</a>是由 Troy Sobotka 编写一套 color management。类似于ACES<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> 。<code>Filmic Blender</code> 能够将 <code>8 f-stops</code> 提升至 <code>25 f-stops</code>。</p><div class="figure"><img src="" alt="Filmic Blender的dynamic range爆表" class="b-lazy" data-src="/images/2017-BlenderFilmic/new-f-stops.png"><p class="caption">Filmic Blender的dynamic range爆表</p></div><p>最重要的是Troy非常慷慨将 <code>Filmic Blender</code> 对community开源，并且完全免费。</p><h3 id="安装-filmic-blender">安装 Filmic Blender</h3><ol style="list-style-type: decimal"><li><a href="https://github.com/sobotka/filmic-blender" target="_blank" rel="noopener">Github项目页面</a>找到 <em>Clone or Download</em> 按钮， 点击后选择 <em>Download Zip</em> 下载zip压缩包。</li><li>解压到blender <strong>datafiles</strong> 目录下。<ul><li>Windows用户，这个目录处于blender安装目录下，可能是 C:/Program Files/Blender Foundation/Blender/&lt;version&gt;/datafiles</li><li>Linux用户，/home/$user/.blender/&lt;version&gt;/datafiles。其中 <em>$user</em> 及用户名。</li><li>Mac用户，进入Resources文件夹后，blender.app/Contents/Resources/&lt;version&gt;/datafiles</li></ul></li><li>将 <strong>datafiles</strong> 目录下原来的 <strong>colormanagement</strong> 改为别的名字（例如 colormanagement_bak）作为备份。</li><li>将改解压的文件夹改为 <strong>colormanagement</strong> 作为新的颜色管理配置。 注意打开后能看到 <em>looks</em> 以及 <em>luts</em> 这两个文件夹，确保目录结构正确。</li><li><p>打开blender，进入 <strong>Scene</strong> 标签，在 <strong>Color Management</strong> 下点开 <strong>View</strong> 应该能看到如下图的选项。 其中 <code>Filmic Log Encoding Base</code> 就是我们的主角了。</p><div class="figure"><img src="" alt="Filmic Blender Color Management 菜单" class="b-lazy" data-src="/images/2017-BlenderFilmic/menu-filmic.png"><p class="caption">Filmic Blender Color Management 菜单</p></div></li></ol><h3 id="使用-filmic-blender">使用 Filmic Blender</h3><ul><li><code>color management</code>下面的 <code>view</code> 选为 <code>Filmic Log Encoding Base</code> 。</li><li><p>将 <code>look</code> 选为 <code>Base Contrast</code> 。</p><blockquote><p>没有选择 <code>None</code> 时候，类似于相片Raw格式，<code>look</code> 中的选项相当于应用一个 lookup table。</p></blockquote></li><li><p>在高动态范围下，你可以将场景里面的光源亮度提高，让你的场景拥有足够的光线。</p></li></ul><h3 id="使用-false-color-让场景的曝光度明确可见">使用 False Color 让场景的曝光度明确可见</h3><p>以往调整光源的时候往往就是肉眼观察，然后不断尝试感觉差不多了。 但现在Filmic Blender有一个量化工具来辅助， 当 <code>look</code> 设为 <code>False Color</code>，就能够将场景内曝光度可视化，可以根据其来调整光源强度。</p><p>该设置下，会用不同颜色表示不同的曝光度:</p><table style="width:62%;"><colgroup><col width="20%"><col width="41%"></colgroup><thead><tr class="header"><th align="left">Value</th><th align="left">Color</th></tr></thead><tbody><tr class="odd"><td align="left">Low Clip</td><td align="left">Black</td></tr><tr class="even"><td align="left">-10 EV</td><td align="left">Purple</td></tr><tr class="odd"><td align="left">-7 EV</td><td align="left">Blue</td></tr><tr class="even"><td align="left">-4 EV</td><td align="left">Cyan</td></tr><tr class="odd"><td align="left">-2 EV</td><td align="left">Green</td></tr><tr class="even"><td align="left">0 EV</td><td align="left">Grey</td></tr><tr class="odd"><td align="left">+2 EV</td><td align="left">Green</td></tr><tr class="even"><td align="left">+4 EV</td><td align="left">Yellow</td></tr><tr class="odd"><td align="left">+5.5 EV</td><td align="left">Red</td></tr><tr class="even"><td align="left">High Clip</td><td align="left">White</td></tr></tbody></table><p>白色就是 <code>white cliping</code>，黄色以及红色较亮，黑色就是 <code>black cliping</code>，蓝色以及紫色较暗。</p><div class="figure"><img src="" alt="原来的光照" class="b-lazy" data-src="/images/2017-BlenderFilmic/FalseColor-light-before.jpg"><p class="caption">原来的光照</p></div><p>这个是改进前的场景，打不都是绿色，而且曝光最高的部分才黄色级别，所以光线严重不足。</p><div class="figure"><img src="" alt="增强亮度后的光照" class="b-lazy" data-src="/images/2017-BlenderFilmic/FalseColor-light38&amp;10.jpg"><p class="caption">增强亮度后的光照</p></div><p>改进后，盘子有些反光，然后面包圈上的酱料有少许高光。</p><p>最后再将 <code>look</code> 改回 <code>Base Constract</code>，查看下改进后的渲染效果：</p><div class="figure"><img src="" alt="改进后的渲染效果" class="b-lazy" data-src="/images/2017-BlenderFilmic/light38&amp;10_1.jpg"><p class="caption">改进后的渲染效果</p></div><p>原先光源数据：主光源15，辅光源5。改进后光源数据：主光源38，辅光源10。 亮度提升了一倍多，场景内光线充足后，我们的渲染效果就闪耀了。</p><h2 id="总结">总结</h2><p>Blender 的 Cycles 渲染器效果非凡，我们通过修正了其color management，最后补足最后缺陷。 使其 PBR<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> 效果的以正确显示，最终达到照片级的真实效果。</p><p>视频大概3月份发布，我也差不多一个月后发现并观看了，并用我的面包圈作品练手。 本来当时做完渲染作品，就想写这篇文章来推荐这个我极大受益的方法， 但拖了4个月，眼看blender 2.8版本就要正式版了，2.8内置类似<code>Filmic</code>的功能，再不写有些内容就快过时了。</p><p>虽说即将到来的新版本已经意识到并解决老blender的这个问题，但这篇文章或者上述的教程视频依旧有用， 因为会介绍原理层面（很容易理解），知其所以然。</p><div class="footnotes"><hr><ol><li id="fn1"><p><a href="https://www.unrealengine.com/en-US/blog/unreal-engine-4-15-released?lang=en-US" target="_blank" rel="noopener">4.15发布日志</a> 新的基于<code>ACES</code>的<code>Filmic Tonemapping</code>特性以及对应的新的<code>Post Progress</code>后期处理的工具， 如果你用过以前版本，4.15的Post Progress有很大变化，而且相关工作流<code>workflow</code>有些不同，UE4团队有相关新特性的U2B视频教程 <a href="https://youtu.be/A-wectYNfRQ" target="_blank" rel="noopener">Filmic Tonemapper | Feature Highlight</a><a href="#fnref1">↩</a></p></li><li id="fn2"><p>Academy Color Encoding System 是在电影以及电视领域用于管理色彩的工业标准。 此处 Academy 也是奥斯卡奖的那个学院。更多关于ACES介绍浏览 <a href="http://www.oscars.org/science-technology/sci-tech-projects/aces" class="uri" target="_blank" rel="noopener">http://www.oscars.org/science-technology/sci-tech-projects/aces</a><a href="#fnref2">↩</a></p></li><li id="fn3"><p>Physically Based Rendering 基于物理现实的渲染<a href="#fnref3">↩</a></p></li></ol></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我曾经在我的文章 &lt;a href=&quot;/2017/04/01/blender-cycles-render-donuts/&quot; title=&quot;Blender Cycles渲染作品 面包圈&quot;&gt;Blender Cycles渲染作品 面包圈&lt;/a&gt; 提到发现一个改进方法，能够大幅提高渲染 &lt;em&gt;render&lt;/em&gt; 效果。&lt;/p&gt;
&lt;p&gt;本文我会通过上面提及的面包圈作品作为实例，来谈论原生blender &lt;code&gt;dynamic range 动态范围&lt;/code&gt;的限制。 以及突破限制的方式，即&lt;code&gt;Filmic Blender&lt;/code&gt;插件，最终能带来不可思议的照片级渲染效果。&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;/images/2017-BlenderFilmic/filmic-before&amp;amp;after.jpg&quot; alt=&quot;渲染效果对比 右边改进的作品 提升效果明显&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;渲染效果对比 右边改进的作品 提升效果明显&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这个改进方法我是从blenderguru的一个非常棒的&lt;a href=&quot;https://youtu.be/m9AT7H4GGrA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;教程视频 The Secret Ingredient to Photorealism&lt;/a&gt;学到的。 如果英语还行并且能上U2B，我极力推荐观看。我文章基本就是根据视频整理得出，额外加些我的内容。&lt;/p&gt;
&lt;p&gt;另外本文基于blender编写，但是里面相当多的内容并不局限于blender，甚至&lt;code&gt;Filmic&lt;/code&gt;的幕后实现也是基于其他领域的成果（下面正文&lt;!-- TODO link to the section--&gt;我会介绍）。 所以如果你使用其他CG或者渲染软件，以及别的相关领域也建议了解下。
    
    </summary>
    
    
      <category term="CG" scheme="http://www.mix-flow.com/tags/CG/"/>
    
      <category term="blender" scheme="http://www.mix-flow.com/tags/blender/"/>
    
      <category term="PBR" scheme="http://www.mix-flow.com/tags/PBR/"/>
    
      <category term="ACES" scheme="http://www.mix-flow.com/tags/ACES/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript无类型(class free)面向对象编程</title>
    <link href="http://www.mix-flow.com/2017/08/24/JavaScript-class-free-OOP/"/>
    <id>http://www.mix-flow.com/2017/08/24/JavaScript-class-free-OOP/</id>
    <published>2017-08-24T13:08:17.000Z</published>
    <updated>2018-05-30T10:32:46.937Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍无类别面向对象<code>class-free OOP</code>的编程方式，通过编写函数化构造器来创建对象， 该方式相对比传统<code>伪类 pesudoclassical</code>的方式(使用<code>new</code>调用构造器函数)，更为简单易懂，并且有许多优势。</p><p>这个方法，我是从 <em>Douglas Crockfont</em> 那儿得知的。Douglas是一名JavaScript专家， 写有 <em>JavaScript: The Good Parts</em> ， 中译本名为 <em>JavaScript语言精粹</em>。</p><p>一本非常好的书，实际上我的这篇文章中很多观点以及示例就是来自该书，以及该函数化构造器书中也有详尽介绍。</p><a id="more"></a><h2 id="伪类有什么问题">伪类有什么问题</h2><p>那么伪类是什么 以及 伪类有什么不足的地方？</p><p>首先从起源说起，早期创造JavaScript时，<code>原型 prototype</code>参考了Lua这门语言的原型系统。 偏离当今编程语言的主流风格，当今大多数语言都是<code>基于类 class-based</code>的语言。 尽管原型继承有其自己的表现力（对象可以直接从其他对象继承属性，无类型），但它并未被广泛理解。<br>另外，JavaScript提供了一套类似 基于类语言的对象构建方法。 有类型化语言编程经验的程序员很少有愿意接受原型，并认为借鉴类型化的语言模糊了JavaScript真实的原型本质，结果两边都不讨好。</p><p>这种语法类似类型化语言，但本质还是原型，我们在JavaScript中称其为<code>伪类 pesudoclassical</code>，一般类似代码如下： <figure class="highlight javascript"><figcaption><span>JavaScript constructor invocation</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创造名为Que的构造器函数，并带有一个 status 属性。</span></div><div class="line"><span class="keyword">var</span> Que = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.status = str;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 通过prototype来给Que所有实例增加一个 get_status 的公共方法。</span></div><div class="line">Que.prototype.get_status = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.status;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个Que实例。</span></div><div class="line"><span class="keyword">var</span> myQue = <span class="keyword">new</span> Que(<span class="string">"confused"</span>);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.writeln( myQue.get_status() ); <span class="comment">// 打印输出结果 "confused"。</span></div></pre></td></tr></table></figure></p><p>函数如果其目的就是要配合<code>new</code>来一起使用，这种函数一般称作<code>构造器函数</code>。 使用构造器函数来构造对象，这几乎是JavaScript程序员的常用方法，比如大部分JavaScript Libraries，但普遍并<strong>不代表完美</strong>。</p><h3 id="没有加new会有问题">没有加new，会有问题</h3><p>构造器函数依旧是函数，为了与普通函数区分，约定俗成用大写首字母的变量名。</p><p>但是调用构造器函数的时候，如果没有加<code>new</code>可能会发生非常糟糕的事情，既没有编译时报错， 也没有运行时报错。</p><p>而且忘记加<code>new</code>，有一个严重危害，this不会绑定在新对象之上。 更加悲剧的是，this会绑定到全局对象。 所以你不但没有正确创建对象，反而破坏了全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pseudo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"dangerous"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 忘记加上 new</span></div><div class="line"><span class="keyword">var</span> obj = Pseudo();</div><div class="line"></div><div class="line"><span class="comment">// 全局变量里面多了 名为 name 的变量</span></div><div class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出结果 "dangerous"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// 输出结果 "dangerous"</span></div></pre></td></tr></table></figure><p>上述代码我们创建对象的时候，没有加上<code>new</code>，全局变量里面多了<code>name</code>变量，这不是该函数的本意。</p><h3 id="其他伪类的问题">其他“伪类”的问题</h3><p>首先，伪类创建的实例中，所有属性都是公开的，没有私有环境。</p><p>再者，在使用伪类时扩展原型以及继承，本质是操作prototype， 伪类本意是靠近面向对象，但实际看起来格格不入。 这方面详情可以参照 <em>JavaScript语言精粹</em> 第五章的第一节伪类，这方面不是本文重点不做详述。</p><p>这种prototype操作不直观，导致代码实现丑陋， 这也许是新手学习prototype困难的原因（至少我当年刚接触prototype时很疑惑）。 即使隐藏那些无谓的prototype的实现细节，伪类也还是由之前提及的问题。</p><p>在基于类的语言中，类继承是代码重用的唯一方式，而JavaScript有着更多且更好的选择。</p><h2 id="无类别-与-函数化">无类别 与 函数化</h2><p>前面提及，创造JavaScript时prototype参考Lua。但当年JavaScript还参考诸多语言， 其函数<code>function</code>部分深受Lisp这类函数化语言影响。</p><p>我直接给出函数化<code>functional</code>构造器的代码模板： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">constructor</span> = function(spec)&#123;</div><div class="line">    <span class="keyword">var</span> that, other; <span class="comment">// 私有实例 和 变量</span></div><div class="line"></div><div class="line">    that = &#123;&#125;; <span class="comment">// 创建一个新的对象</span></div><div class="line"></div><div class="line">    <span class="comment">// 添加给这个对象的公开变量 和方法</span></div><div class="line">    that.open_variable = <span class="string">"value"</span>;</div><div class="line">    that.open_function = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> that; <span class="comment">// 返回这个对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>步骤是：</p><ol style="list-style-type: decimal"><li>创建一个新的对象，可以是通过对象字面量，也可以是new和伪类构造器创建的对象， 也可以是<code>Object.create</code>根据已经存在实例来创建的对象，包括别些产生对象的方式。<br>虽然这篇文章是介绍比伪类更加清晰方便的函数化构造器，但“新”构造器并不阻止通过伪类来创建对象， 甚至几乎任何创建对象方式都可以接受。</li><li>定义所需要私有变量和方法，没有任何特殊的，仅通过<code>var</code>语法定义的普通变量。<br>对于这个对象的私有方法，其能够访问到构造器传入的参数<code>argument</code>, <code>that</code>和其他私有成员。</li><li>给这个对象扩充其属性 以及 <code>方法 method</code>, 这些也可以引用之前定义的私有变量和方法。<br></li></ol><p>上述便是函数化构造器的初步介绍，没有难于理解的<code>prototype</code>，拥有私有变量， 而且实现没有依赖一些特定语法，都是JS常用基础的语法。</p><p>这便是前面引文提及的<code>class-free</code>，即<code>pesudoclassical free</code>。通过函数的特性来实现。</p><h3 id="更安全地定义对象成员方法-method">更安全地定义对象成员<code>方法 method</code></h3><p>扩充对象<code>that</code>方法的时候，可以如之前代码一样，分配一个新的函数作为成员方法<code>method</code>： <code>that.method1 = function(){};</code>。</p><p>或者更安全地，可以先定义一个函数（私有的），然后再把他们分配个<code>that</code> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> methodical = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"safer method."</span>;</div><div class="line">&#125;</div><div class="line">that.methodical = methodical;</div></pre></td></tr></table></figure></p><p>分两步优势是，其他需要调用<code>methodical</code>的地方， 可以直接调用<code>methodical()</code>而不是<code>that.methodical()</code>。 如果创建的对象实例的<code>that.methodical</code>哪怕被替换了，通过<code>methodical</code>调用的方法会同样继续工作， 因为直接调用的是定义的私有函数，不受实例修改影响。<br>另一方面，你也可以相反操作，通过<code>that</code>来调用， 以便用户修改的实例方法来覆盖 <em>override</em> 原方法并改变结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">constructor</span> = function()&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span>, that = &#123;&#125;; <span class="comment">// create new object</span></div><div class="line">    <span class="keyword">var</span> fun1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; <span class="comment">// the method will be changed in instance</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"OK"</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"I'm "</span> + fun1() + <span class="string">" "</span> + a;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    that.a = a;</div><div class="line">    that.fun1 = fun1;</div><div class="line">    that.fun2 = fun2;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> that;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">constructor</span>();</div><div class="line">// 修改实例</div><div class="line">obj.a = 100</div><div class="line">obj.fun1 = function() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"changed"</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">document</span>.writeln( obj.a ) <span class="comment">// 100</span></div><div class="line"><span class="built_in">document</span>.writeln( obj.fun1() ); <span class="comment">// changed</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.writeln( obj.fun2() ); <span class="comment">// I'm OK 1</span></div></pre></td></tr></table></figure><p>上述示例中：<code>obj.fun2()</code>调用方法，由于我们并不通过调用实例<code>that</code>的方法， 而是调用相应私有变量以及<code>fun1</code>函数，所以其输出结果依旧不受影响。 由于更改实例成员，也是常见编程行为操作，这种分两步定义保证代码结果与预期一致， 又不会限制用户操作实例的自由。</p><h3 id="继承">继承</h3><p>关于继承，其实上述函数化构造器是已经包含继承思想了。 在创建对象时，如果不是一个空的对象字面值，而是创建一个存在的对象，这实际就是继承， 后续可以对<code>that</code>进行一些更改，产生差异化。 <blockquote class="pullquote">All is class-free.</blockquote></p><p>只基于对象，摒弃类的观点，这也是纯粹的原型模型，没有模仿类的语法。 比基于类的继承理念更加简单，只熟悉基于类语言的程序员可能感到陌生，但实际是更容易理解。</p><h3 id="superior方法"><code>superior</code>方法</h3><p><code>super</code>以及<code>superior</code>习惯翻译成父类方法，但这里可能“父方法”或“父对象方法”更为准确些。</p><p>我们的函数式构造器，有办法来调用superior方法。首先我们构造一个<code>superior</code>的方法， 它通过方法名取得需要调用的目标函数，之后执行原来的方法，应用参数进行<code>apply</code>调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.method(<span class="string">"superior"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> method = that[name];</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> method.apply(that, <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>原生JavaScript的<code>Object</code>不存在<code>method</code>方法，<code>method</code>方法作用是给对象增加方法， 并隐藏了<code>prototype</code>的实现细节。所以要让上述代码生效，需要先执行如下代码： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.prototype[name]) &#123; <span class="comment">// 对于基本类型，不存在该方法，才进行添加。</span></div><div class="line">        <span class="keyword">this</span>.prototype[name] = func;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p>上述代码中对<code>this</code>的操作<code>var that = this;</code>， 由于JavaScript函数调用<code>function invocation</code>时，this会被绑定到全局对象上, 这是语言设计的一个错误。<br>如果设计正确，内部函数被调用时，<code>this</code>应该仍被绑定在外部函数的<code>this</code>上， 理想设计下，内部函数就能够对外部函数对象的访问权。很可惜，并不处在理想情况下。<br>但解决方案也很简单，<strong>定义一个变量并把<code>this</code>赋值给该变量，内部函数便可通过该变量访问到<code>this</code></strong>, 变量名约定俗称为<code>that</code>。<br><em>—— JavaScript语言精粹</em> <em>第四章函数 函数调用模式小节</em></p></blockquote><h3 id="示例场景">示例场景</h3><p>要尝试示例代码的话，不要忘记先执行上一小节的<code>Function.prototype.method</code>和<code>Object.superior</code>的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mammal = <span class="function"><span class="keyword">function</span>(<span class="params">spec</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = &#123;&#125;;</div><div class="line">    that.get_name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> spec.name;</div><div class="line">    &#125;;</div><div class="line">    that.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> spec.saying || <span class="string">""</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> that;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat = <span class="function"><span class="keyword">function</span>(<span class="params">spec</span>) </span>&#123;</div><div class="line">    spec.saying = spec.saying || <span class="string">"meow"</span>; <span class="comment">// default "meow"</span></div><div class="line">    <span class="keyword">var</span> that = mammal(spec);</div><div class="line">    that.get_name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> that.say() + <span class="string">" "</span> + spec.name + <span class="string">" "</span> + that.say();</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> that;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> coolcat = <span class="function"><span class="keyword">function</span>(<span class="params">spec</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = cat(spec),</div><div class="line">        super_get_name = that.superior(<span class="string">"get_name"</span>);</div><div class="line">    that.get_name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"like "</span> + super_get_name() + <span class="string">" baby"</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> that;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cooldog = <span class="function"><span class="keyword">function</span>(<span class="params">spec</span>) </span>&#123;</div><div class="line">    spec.saying = spec.saying || <span class="string">"Woof!"</span></div><div class="line">    <span class="keyword">var</span> that = coolcat(spec);</div><div class="line">    <span class="keyword">return</span> that</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> mimi_cat = coolcat(&#123;<span class="attr">name</span>: <span class="string">"Mimi"</span>&#125;);</div><div class="line"><span class="keyword">var</span> wang_dog = cooldog(&#123;<span class="attr">name</span>: <span class="string">"Wang Cai"</span>&#125;);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.writeln(mimi_cat.get_name()); <span class="comment">// like meow Mimi meow baby</span></div><div class="line"><span class="built_in">document</span>.writeln(wang_dog.get_name()); <span class="comment">// like Woof! Wang Cai Woof! baby</span></div></pre></td></tr></table></figure><p>上面示例代码应该算简单明确，不做过多解释，其中<code>coolcat</code>通过<code>superior</code>调用的父对象的方法。</p><p>关于函数化，详细部分可参考 <em>JavaScript语言精粹</em> 第五章继承 <em>Inheritance</em> 的 函数化 <em>Functional</em> 小节。</p><!-- 关于最后一个`cooldog`继承自`coolcat`有些怪，设想如下场景，我需要`coolcat`的`get_name`，如代码所示是很方便复用代码的方法，如果你非觉得“狗继承猫”不能接受，我只能给出如下解释：1. 鸭子类型 duck type，我只想关心功能。（如果你没听说过鸭子类型，请自行搜索或wiki，一个常见的理念。）    > "If it walks like a duck and it quacks like a duck, then it must be a duck."2. 这些变量名只是名字，我也许想出有更合适名字示例，也许这样你就不用纠结，但代码功能还是换汤不换药。另外保留这种“冲突”，我感到有少许戏剧感。实际上这个示例就是 _JavaScript语言精粹_ 中的示例，除了`cooldog`是我写文章临时起意创作续上的。 --><h2 id="函数化构造器也不是完美的">函数化构造器也不是完美的</h2><p>抛开类的感念，专注于对象，再结合函数化，这种理念直观容易理解。 可是没有绝对完美的事物，不光这样，函数式构造器的“缺陷”也是来自于带来优点的特征。</p><p>我们的方法不涉及操作<code>prototype</code>，带来便利的同时， 我们失去一些JavaScript设计的一些prototype的特性：</p><ul><li><p>通过prototype继承(prototype chain原型链)，可以复用父类成员，可以节省一些内存。 而函数化构造器每次创建新对象实例，每个都是独立内存空间的。</p></li><li><p>诸如<code>instanceof</code>，这种本质通过prototype实现的方法，对于函数化创建的实例是无效的。</p></li></ul><p>但上述两点“缺陷”，其实也不是难以接受，下面我分别给出解释。</p><ul><li><p>我们现在硬件水准，足够允许我们能够不节省这些空间， 一般来说，属性成员所占内存空间太微不足道了。<br>正常情况下，很难因为属性没复用导致性能问题。</p><blockquote><p>退一步，真的遇到有个变量达到令人发指的大小，最简单解决方法，提取出来作为一个普通变量， 不作为成员属性。另外不想直接暴露在公共对象的话，利用函数将其限定期望的<code>作用域scope</code>内。</p><p>最后再考虑下，有没有比直接作为变量更好的方式。</p></blockquote></li><li><p><code>instanceof</code>还是类似 基于类语言的语法。在无类型语言中，<code>鸭子类型 duck type</code>也能实现。</p><blockquote><p>举例来说，我项目涉及JavaScript（比如这个博客网站），我不使用JQuery， 我自己写了一个轻量级的操作DOM元素 <em>DOM Element</em> 的library，名为domutil。 类似JQuery，创建一个wrapper包装对象，其中一个成员名为<code>el</code>存放便是原生DOM元素。 其中有些工具方法，是需要操作DOM的，同时为了为了更易用，其接受参数值，可能是wrapper对象 也能就是原生DOM。</p><p>这时候我只需要判断接受对象是否有<code>el</code>成员，如果有通过<code>el</code>取得DOM元素 如果没有则认为对象就是DOM元素。两种情况最终都获得DOM，然后再进行后续处理。（可参考<code>wrap</code>方法，其作用是给一个DOM包裹到另一个DOM之中） 这样就无需类型系统中判断类别的处理。</p></blockquote></li></ul><h2 id="总结">总结</h2><p>对于只熟悉基于类语言的程序员（一般使用<code>面向对象OOP</code>语言），可能对本文有些观点感到陌生。（包括刚做程序员的我，当时我仅熟悉Java） 对此，借用我上过的一门公开课<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> 的老师的话：</p><blockquote><p>“函数化实际上是比OOP简单的，你感觉相反，是因为有先入为主的影响（先学的基于类的语言），实际上函数化更为简单，OOP更为复杂。”</p></blockquote><p>另外，本文也不是争论OOP与函数化那个更优秀，两种方式是程序语言设计两条方向， 如今现代语言也是两者兼备融合，即使严重偏向一方的语言也开始融合另一方的特性， 这种趋势就我认为就是说明，没有孰优孰劣之分。</p><p>当今函数化受众可能没有类型系统（其中大头Java C++）多， 所以也希望更多人能体会到函数化的优点，并且也不仅局限于JavaScript，有些理念是语言相同的。</p><div class="footnotes"><hr><ol><li id="fn1"><p>华盛顿大学 Dan Grossman教授的 <a href="https://www.coursera.org/learn/programming-languages" target="_blank" rel="noopener">cousera课程</a>。非常推荐学习， 课程专注于程序语言背后共性，并不是仅介绍如何使用某类语言的语法课程（虽说这部分内容也是很多）， 而是更深入的思考。<br> 会涉及<code>ml</code>,<code>ruby</code>,<code>racket</code>这三门语言，学完你会发现，市面上很多新语言新特性实际上可能并不那么新， 甚至某些特性可以称得上历史悠久，仅仅是一直没有成为主流。<a href="#fnref1">↩</a></p></li></ol></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍无类别面向对象&lt;code&gt;class-free OOP&lt;/code&gt;的编程方式，通过编写函数化构造器来创建对象， 该方式相对比传统&lt;code&gt;伪类 pesudoclassical&lt;/code&gt;的方式(使用&lt;code&gt;new&lt;/code&gt;调用构造器函数)，更为简单易懂，并且有许多优势。&lt;/p&gt;
&lt;p&gt;这个方法，我是从 &lt;em&gt;Douglas Crockfont&lt;/em&gt; 那儿得知的。Douglas是一名JavaScript专家， 写有 &lt;em&gt;JavaScript: The Good Parts&lt;/em&gt; ， 中译本名为 &lt;em&gt;JavaScript语言精粹&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;一本非常好的书，实际上我的这篇文章中很多观点以及示例就是来自该书，以及该函数化构造器书中也有详尽介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="programming" scheme="http://www.mix-flow.com/tags/programming/"/>
    
      <category term="OOP" scheme="http://www.mix-flow.com/tags/OOP/"/>
    
      <category term="JavaScript" scheme="http://www.mix-flow.com/tags/JavaScript/"/>
    
      <category term="prototype" scheme="http://www.mix-flow.com/tags/prototype/"/>
    
      <category term="functional" scheme="http://www.mix-flow.com/tags/functional/"/>
    
      <category term="programming language" scheme="http://www.mix-flow.com/tags/programming-language/"/>
    
  </entry>
  
  <entry>
    <title>UE4作品 林中小径 含全景图</title>
    <link href="http://www.mix-flow.com/2017/08/22/UE4-work-forest-path-with-panorama/"/>
    <id>http://www.mix-flow.com/2017/08/22/UE4-work-forest-path-with-panorama/</id>
    <published>2017-08-22T11:32:00.000Z</published>
    <updated>2017-09-18T13:13:21.431Z</updated>
    
    <content type="html"><![CDATA[<div class="figure"><img src="" alt="清晨 视角2" class="b-lazy" data-src="/images/2017-ForestPath/Forest_Day2.jpg"><p class="caption">清晨 视角2</p></div><a id="more"></a><div class="figure"><img src="" alt="清晨 视角1" class="b-lazy" data-src="/images/2017-ForestPath/Forest_Day.jpg"><p class="caption">清晨 视角1</p></div><div class="figure"><img src="" alt="清晨 雾气(体积光) 视角1" class="b-lazy" data-src="/images/2017-ForestPath/Forest_Day_Fog.jpg"><p class="caption">清晨 雾气(体积光) 视角1</p></div><div class="figure"><img src="" alt="阴天or傍晚 视角1" class="b-lazy" data-src="/images/2017-ForestPath/Forest_Night_Cloudy.jpg"><p class="caption">阴天or傍晚 视角1</p></div><div class="figure"><img src="" alt="阴天or傍晚 雾气(体积光) 视角1" class="b-lazy" data-src="/images/2017-ForestPath/Forest_Night_Cloudy_Fog.jpg"><p class="caption">阴天or傍晚 雾气(体积光) 视角1</p></div><div class="figure"><img src="" alt="阴天or傍晚 雾气(体积光) 视角2" class="b-lazy" data-src="/images/2017-ForestPath/Forest_Night_Cloudy_Fog2.jpg"><p class="caption">阴天or傍晚 雾气(体积光) 视角2</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;&quot; alt=&quot;清晨 视角2&quot; class=&quot;b-lazy&quot; data-src=&quot;/images/2017-ForestPath/Forest_Day2.jpg&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;清晨 视角2&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="my work" scheme="http://www.mix-flow.com/categories/my-work/"/>
    
      <category term="ue4" scheme="http://www.mix-flow.com/categories/my-work/ue4/"/>
    
    
      <category term="CG" scheme="http://www.mix-flow.com/tags/CG/"/>
    
      <category term="UE4" scheme="http://www.mix-flow.com/tags/UE4/"/>
    
      <category term="unreal engine" scheme="http://www.mix-flow.com/tags/unreal-engine/"/>
    
      <category term="PBR" scheme="http://www.mix-flow.com/tags/PBR/"/>
    
      <category term="3D" scheme="http://www.mix-flow.com/tags/3D/"/>
    
      <category term="forest" scheme="http://www.mix-flow.com/tags/forest/"/>
    
      <category term="jungle" scheme="http://www.mix-flow.com/tags/jungle/"/>
    
      <category term="panorama" scheme="http://www.mix-flow.com/tags/panorama/"/>
    
      <category term="landscape" scheme="http://www.mix-flow.com/tags/landscape/"/>
    
      <category term="grass" scheme="http://www.mix-flow.com/tags/grass/"/>
    
  </entry>
  
  <entry>
    <title>使用Neural Style转变图像艺术风格</title>
    <link href="http://www.mix-flow.com/2017/06/27/image-style-transfer-using-neural-style/"/>
    <id>http://www.mix-flow.com/2017/06/27/image-style-transfer-using-neural-style/</id>
    <published>2017-06-27T12:57:26.000Z</published>
    <updated>2018-03-16T07:36:28.730Z</updated>
    
    <content type="html"><![CDATA[<p>Neural style是一种<code>convolution neural network卷积神经网路</code>算法。一个非常有意思的算法， 能够将一幅图转化为另一幅图的风格。</p><p>项目代码: <a href="https://github.com/mixflow/neural-style" target="_blank" rel="noopener">github repo</a></p><p>例如可以将照片转化为名画的艺术风格:</p><div class="figure"><img src="" alt="浮世绘风格作品" class="b-lazy" data-src="/images/2017-neural-style/output/forest_wave.jpg" style="max-height:620px;"><p class="caption">浮世绘风格作品</p></div><a id="more"></a><p>该作品就是将一张森林的照片（下一图）转化的，所使用艺术风格画作是「神奈川沖浪裏」（下二图）。</p><figure class="image-figure "><img src="/images/util/loading.gif" alt="原图 森林" class="b-lazy" data-src="/images/2017-neural-style/content/forest.jpg"> <img src="/images/util/loading.gif" alt="浮世绘 神奈川沖浪裏" class="b-lazy" data-src="/images/2017-neural-style/style/wave.jpg"><figcaption>原图 森林 &amp; 浮世绘 神奈川沖浪裏</figcaption></figure><h2 id="其他转变风格作品">其他转变风格作品</h2><h3 id="星夜">星夜</h3><figure class="image-figure too-width "><div class="figure"><img src="/images/util/loading.gif" alt="原图 小镇" class="b-lazy" data-src="/images/2017-neural-style/content/ALSACE.jpg"><p class="caption">原图 小镇</p></div><div class="figure"><img src="/images/util/loading.gif" alt="星夜" class="b-lazy" data-src="/images/2017-neural-style/style/starry_night.jpg"><p class="caption">星夜</p></div></figure><div class="figure"><img src="" alt="星夜风格 转化作品" class="b-lazy" data-src="/images/2017-neural-style/output/ALSACE_starry.jpg"><p class="caption">星夜风格 转化作品</p></div><p>原图的小镇名<code>ALSACE</code> <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p><h3 id="大碗岛河畔的星期天-a-sunday-on-la-grande-jatte">大碗岛河畔的星期天 A Sunday on La Grande Jatte</h3><figure class="image-figure too-width "><div class="figure"><img src="" alt="原图 小镇" class="b-lazy" data-src="/images/2017-neural-style/content/ALSACE.jpg"><p class="caption">原图 小镇</p></div><div class="figure"><img src="" alt="大碗岛河畔的星期天" class="b-lazy" data-src="/images/2017-neural-style/style/sunday.jpg"><p class="caption">大碗岛河畔的星期天</p></div></figure><div class="figure"><img src="" alt="大碗岛河畔的星期天 风格" class="b-lazy" data-src="/images/2017-neural-style/output/ALSACE_sunday.jpg"><p class="caption">大碗岛河畔的星期天 风格</p></div><h3 id="抽象风格-composition-vii">抽象风格 Composition VII</h3><figure class="image-figure too-width "><div class="figure"><img src="" alt="原图 小镇" class="b-lazy" data-src="/images/2017-neural-style/content/ALSACE.jpg"><p class="caption">原图 小镇</p></div><div class="figure"><img src="" alt="Composition VII" class="b-lazy" data-src="/images/2017-neural-style/style/composition_vii.jpg"><p class="caption">Composition VII</p></div></figure><div class="figure"><img src="" alt="Composition VII 风格" class="b-lazy" data-src="/images/2017-neural-style/output/ALSACE_vii.jpg"><p class="caption">Composition VII 风格</p></div><h4 id="公园-composition-vii">公园 + Composition VII</h4><figure class="image-figure"><div class="figure"><img src="" alt="原图 公园" class="b-lazy" data-src="/images/2017-neural-style/content/namba_parks.jpg"><p class="caption">原图 公园</p></div><div class="figure"><img src="" alt="Composition VII" class="b-lazy" data-src="/images/2017-neural-style/style/composition_vii.jpg"><p class="caption">Composition VII</p></div></figure><div class="figure"><img src="" alt="Composition VII 风格" class="b-lazy" data-src="/images/2017-neural-style/output/namba_parks_vii.jpg"><p class="caption">Composition VII 风格</p></div><div class="footnotes"><hr><ol><li id="fn1"><p><a href="https://www.medyatv.org/2016-da-en-iyi-tatil-secenekleri/" target="_blank" rel="noopener">图片来源</a>, 准确说法为一个法国地区.<a href="#fnref1">↩</a></p></li></ol></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Neural style是一种&lt;code&gt;convolution neural network卷积神经网路&lt;/code&gt;算法。一个非常有意思的算法， 能够将一幅图转化为另一幅图的风格。&lt;/p&gt;
&lt;p&gt;项目代码: &lt;a href=&quot;https://github.com/mixflow/neural-style&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例如可以将照片转化为名画的艺术风格:&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;&quot; alt=&quot;浮世绘风格作品&quot; class=&quot;b-lazy&quot; data-src=&quot;/images/2017-neural-style/output/forest_wave.jpg&quot; style=&quot;max-height:620px;&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;浮世绘风格作品&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="my work" scheme="http://www.mix-flow.com/categories/my-work/"/>
    
      <category term="machine learning" scheme="http://www.mix-flow.com/categories/my-work/machine-learning/"/>
    
      <category term="neural network" scheme="http://www.mix-flow.com/categories/my-work/machine-learning/neural-network/"/>
    
    
      <category term="programming" scheme="http://www.mix-flow.com/tags/programming/"/>
    
      <category term="CG" scheme="http://www.mix-flow.com/tags/CG/"/>
    
      <category term="convolution neural network" scheme="http://www.mix-flow.com/tags/convolution-neural-network/"/>
    
      <category term="nerual network" scheme="http://www.mix-flow.com/tags/nerual-network/"/>
    
      <category term="machine learing" scheme="http://www.mix-flow.com/tags/machine-learing/"/>
    
      <category term="art" scheme="http://www.mix-flow.com/tags/art/"/>
    
      <category term="neural style" scheme="http://www.mix-flow.com/tags/neural-style/"/>
    
  </entry>
  
  <entry>
    <title>Blender Cycles渲染作品 面包圈</title>
    <link href="http://www.mix-flow.com/2017/04/01/blender-cycles-render-donuts/"/>
    <id>http://www.mix-flow.com/2017/04/01/blender-cycles-render-donuts/</id>
    <published>2017-04-01T10:27:54.000Z</published>
    <updated>2017-08-15T09:04:00.192Z</updated>
    
    <content type="html"><![CDATA[<ul><li>制作软件: blender</li><li>渲染软件: blender cycles</li></ul><p>这个是我最初接触3D制作，其中一个跟着教程做的作品。教程来自<a href="http://www.blenderguru.com/" target="_blank" rel="noopener">blenderguru</a>（英文）。</p><p>最初做完并没有下图的水准。直到最近发现了一个针对blender cycles的改进，就拿这个当年练手作品试验了下，质量大幅度提升。（之后可能会写篇文章介绍）</p><p>个人非常满意现在的效果：</p><div class="figure"><img src="" alt="主视角" class="b-lazy" data-src="/images/2017-Donuts/result1.jpg"><p class="caption">主视角</p></div><a id="more"></a><div class="figure"><img src="" alt="俯视 并不是专门设计的视角，只是为了从另一个角度查看" class="b-lazy" data-src="/images/2017-Donuts/result2.jpg"><p class="caption">俯视 并不是专门设计的视角，只是为了从另一个角度查看</p></div><p>上一张图亮度有些高（有点过曝的感觉），个人稍微调整了下，以便观看效果更好点。<br>进行的操作：对比度略微调强（糖浆颜色更突出），亮度略微调低。</p><p><em>个人并不是专业摄影师，没有经过专门后期处理的培训，只是凭自己的感官调整差不多个人满意的效果。</em></p><div class="figure"><img src="" alt="上张俯视效果图 后期处理" class="b-lazy" data-src="/images/2017-Donuts/result3.jpg"><p class="caption">上张俯视效果图 后期处理</p></div>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;制作软件: blender&lt;/li&gt;
&lt;li&gt;渲染软件: blender cycles&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个是我最初接触3D制作，其中一个跟着教程做的作品。教程来自&lt;a href=&quot;http://www.blenderguru.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;blenderguru&lt;/a&gt;（英文）。&lt;/p&gt;
&lt;p&gt;最初做完并没有下图的水准。直到最近发现了一个针对blender cycles的改进，就拿这个当年练手作品试验了下，质量大幅度提升。（之后可能会写篇文章介绍）&lt;/p&gt;
&lt;p&gt;个人非常满意现在的效果：&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;&quot; alt=&quot;主视角&quot; class=&quot;b-lazy&quot; data-src=&quot;/images/2017-Donuts/result1.jpg&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;主视角&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="my work" scheme="http://www.mix-flow.com/categories/my-work/"/>
    
      <category term="blender" scheme="http://www.mix-flow.com/categories/my-work/blender/"/>
    
      <category term="cycles" scheme="http://www.mix-flow.com/categories/my-work/blender/cycles/"/>
    
    
      <category term="CG" scheme="http://www.mix-flow.com/tags/CG/"/>
    
      <category term="blender" scheme="http://www.mix-flow.com/tags/blender/"/>
    
      <category term="PBR" scheme="http://www.mix-flow.com/tags/PBR/"/>
    
      <category term="3D" scheme="http://www.mix-flow.com/tags/3D/"/>
    
      <category term="cycles" scheme="http://www.mix-flow.com/tags/cycles/"/>
    
      <category term="render" scheme="http://www.mix-flow.com/tags/render/"/>
    
  </entry>
  
  <entry>
    <title>使用Ruby写一个Racket(Scheme)解释器</title>
    <link href="http://www.mix-flow.com/2017/02/20/write-racket-scheme-interpreter-on-ruby/"/>
    <id>http://www.mix-flow.com/2017/02/20/write-racket-scheme-interpreter-on-ruby/</id>
    <published>2017-02-20T05:38:05.000Z</published>
    <updated>2017-12-26T06:13:55.930Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/symbol/lambda.svg" class="center" width="200" title="lambda symbol"><p>如果学习Lisp系语言，可能在后期都会实现一个本语言的解释器<code>interpreter</code>来练个手。</p><p>我学的是 Lisp(或者说Scheme) 方言之一的Racket，自己当时能写解释器的时候的确感觉不一样。<br>毕竟之前也接触过很多语言，基本都是学的语言特性<code>feature</code>，和其流行的package使用(比如web框架)。很少接触过语言实现<code>language implemention</code>的知识。</p><p>当自己能写出解释器的时候，感觉到一种新的学习语言的体验。</p><p>这篇文章努力做到新手友好，只需要有一定编程知识基础(可能只要懂一门语言)即可阅读。</p><p>项目github链接：<a href="https://github.com/mixflow/RacketOnRuby/" class="uri" target="_blank" rel="noopener">https://github.com/mixflow/RacketOnRuby/</a> <a id="more"></a></p><h2 id="语言相关介绍">语言相关介绍</h2><p>Ruby现在还算有些名声，现在的程序员即使没用过的，可能都知道有这门语言。<br>但是Lisp Scheme可能很多程序员都没听说过， 我当年阅读了别人推荐的《黑客与画家》 这本书才有所了解，在此之前我似乎连Lisp或者Scheme的名字都没见过。 所以有必要先简介一下。</p><h3 id="lisp-scheme-racket-是什么">Lisp Scheme Racket 是什么?</h3><p>Lisp是一门诞生于上个世纪50年代的语言。其后有很多相同思想的语言，都算得上Lisp家族的，一般被称为Lisp 方言<code>dialect</code>， 其中就包括这里提及的另外两个语言Racket Scheme。Scheme年代更加久远，影响也大些。Racket相比之下更年轻些。</p><p>这篇文章只涉及语言基本简单特征实现，这块哪怕语法上面Racket Scheme都没什么区别， 所以这里的Racket解释器也可看作Scheme解释器。也就是说能解释执行Scheme代码。</p><h3 id="why-use-ruby">Why use Ruby?</h3><ol style="list-style-type: decimal"><li>当时正好也在学Ruby，所以就用Ruby实现下，纯练手。</li><li>这个是第二个编译器实现。最早第一个是当时学习Racket的时候，使用Racket本身实现的，编写了一个<code>metacirclar evaluator</code>，这种方式可以跳过<code>parse</code>步骤（详见紧接着的下文），因为写的代码就已经是AST了（依旧详见下文）。那么用Ruby来实现Racket的话，是需要<code>parser</code>，所以也能再多练一些(虽说parser也没什么复杂的)。</li><li>《黑客与画家》中 <em>“如果回到1975年，你声称它(Ruby)是一种有着自己语法的Lisp方言，没有人会提出反对意见。”</em>。<br>作者认为Ruby也可以视为Lisp的一种方言。那么我反过来通过Lisp的方言来实现Lisp，想法有些古怪，但我认为有点意思。</li></ol><h2 id="实现一个编程语言通常的步骤">实现一个编程语言通常的步骤</h2><p>下面涉及的是一个典型的语言实现<code>language implemention</code>的流程：</p><ol style="list-style-type: decimal"><li>首先接受一串字符串<code>string</code>，其内容就是用此语言编写的程序。如果该字符串不是符合语法结构<em>syntactically well-formed</em>（比如关键字拼写错误等），分析器<code>parser</code>会报错。</li><li>如果没有上述的语法错误，parser会生成一个树<code>tree</code>来表示程序。这个树一般称为<code>abstract-syntax tree</code>，简称为<code>AST</code>。<ul><li>如果语言有<code>类型检查 type-checking</code>或其他原因，认定AST仍然不是一个合法的程序。 <code>类型检查器 type-checker</code>就会生成错误信息。</li><li>如果没有上述错误, AST就会被传递给后续流程。</li></ul></li><li>实现目标编程语言<code>language B</code>的剩余流程，基本就是如下两种方案。<ul><li>可以用另一门语言<code>language A</code>编写<code>解释器 interpreter</code>来接受使用<code>language B</code>编写的程序，并最终产生结果。这里用来实现interpreter的language A，有个专门术语称呼：<code>metalanguage</code>。</li></ul><blockquote><p>如果把这个<code>language A</code>程序称作<code>evaluator for B</code>（evaluate中文对应术语一般叫求值，大概意思达到了，但我个人觉得不太准确）或者<code>执行器 executor for B</code>，可能会更直白些。但<code>解释器 interpreter</code>是约定俗成的术语。</p></blockquote><ul><li>另外一种方式再<code>language A</code>写一个<code>编译器 compiler</code>来将<code>language B</code>写的程序生成一个等价<em>equivalent</em> <code>language C</code>的程序。 然后再使用早已存在的<code>language C</code>语言实现。</li></ul><blockquote><p><code>编译器 compiler</code>可能称为<code>翻译器 translator</code>更好，与interpreter同样的原因，compiler是个普遍使用的术语。</p></blockquote></li></ol><div class="figure"><img src="https://upload.wikimedia.org/wikipedia/commons/d/d6/Parser_Flow%D5%B8.gif" alt="implementing program language workflow from wikipedia parsing"><p class="caption">implementing program language workflow from <a href="https://en.wikipedia.org/wiki/Parsing" target="_blank" rel="noopener">wikipedia parsing</a></p></div><p>另外要说教下，编译器以及解释器只是<strong>编程语言实现方式的特征<em>the feature of a particular programming language implementation</em></strong>，而不是编程语言自身的特征<em>the feature of the programming language</em>。所以“编译性语言” <em>compile language</em> 或者“解释性语言” <em>interpreter language</em> 的说法<strong>完全没有意义</strong>。完全可以给Lisp,Scheme系语言编写一个compiler(这些语言的解释器实现比较常见)，给C语言编写一个解释器也是完全可行的。</p><h2 id="racket基本语法以及parser实现">Racket基本语法以及parser实现</h2><p>建议先在<a href="http://download.racket-lang.org/" target="_blank" rel="noopener">Racket官网下载</a>原生Racket以及配套IDE DrRacket，写Racket或者Scheme程序方便些。 另外本文interpreter实现基本不包含检测和错误处理，所以测试代码最好先在原生Racket里面执行下。</p><p>需要快速了解Racket基本语法，推荐此篇快速介绍文章<a href="https://learnxinyminutes.com/docs/racket/" target="_blank" rel="noopener">Learn X in Y minutes, When x = Racket</a>。</p><h3 id="代数运算">代数运算</h3><figure class="highlight scheme"><figcaption><span>Racket</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">3</span>))</div></pre></td></tr></table></figure><p>先来个简单的Racket代码例子，上述代码较内层括号<code>(* 2 3)</code>是乘法运算，然后在外层括号内再将上述乘法运算结果加上2。 整个代码等价于数学或者常见编程语言<code>2 + 2 * 3</code>代码意义。</p><p>一开始就比较不同寻常，对于此类Racket代码可以看作<code>操作符 operator</code>以及<code>操作数 operand</code>的组合，再用括号包裹。比如<code>(+ 1 1)</code>就可以把<code>+</code>看作操作符。另外可以括号形式的代码嵌套，比如上述先乘后加的代数运算。</p><p>这种代码形式，实际非常简单，我们可以给一个更加明确的定义如下节。</p><h3 id="racket所有的东西都是">Racket所有的东西都是：</h3><p>就两种！</p><ol style="list-style-type: decimal"><li>一个<code>atom</code>，比如数字<code>3</code>、字符串<code>&quot;hello&quot;</code>、<code>#t</code>、<code>#f</code>、<code>null</code>。也包括一种atom的：<code>识别符 identifier</code>,可以是<code>变量variable</code>,<br>或者是<code>特别形式special form</code>诸如<code>define</code>、<code>lambda</code>、<code>if</code>。(涉及的名词或者术语，不理解没关系，再后文会一一介绍)</li><li>或者是在括号的一序列<em>sequence</em>东西<code>(t1 t2 t3 ... tn)</code>。</li></ol><p>该定义还有个专门的名称<a href="https://en.wikipedia.org/wiki/S-expression" target="_blank" rel="noopener">S-expression</a>，随着Lisp诞生给出的定义用来描述Lisp。</p><p>详说下第二种情况。括号里的第一东西t1，影响余下的序列中的东西。 如果是<code>special form</code>，比如<code>define</code>，以为定义一个东西，要么是变量<em>variable</em>，要么是函数<em>function</em>（<code>lambda</code>）。</p><p>如果不是<code>special form</code>，剩余情况一般是函数执行<em>function call</em>，很多东西在Racket里都是函数，比如加减<code>+</code>和<code>-</code>。</p><p>在Racket里括号是很常见的，而且括号作用非常明确。不会遇到<code>f x y</code>是<code>(f x) y</code>还是<code>f (x y)</code>的疑惑。 Racket的括号直接影响着<code>解析parsing</code>，将代码转换成树形结构。实际上Racket代码本身就是树形结构。</p><p>如果没有了解过Lisp系语言，大部分人看到一段比较长的代码，都会觉得充满了括号的怪异语法。如果能抛开这些成见，学习使用后实际上能很快适应。</p><h3 id="token">Token</h3><p>具体到parser中第一步<code>生成token token generator</code>或者叫<code>词汇分析lexical Analysis</code>。可以参照上文实现语言通常流程小节引用的流程图，其中’parser’部分。</p><p>这个过程就是把代码字符串分割成多个有意义的符号。这个过程一般使用正则表达式<em>regural expression</em>简称<em>regex</em>。这些符号专门的术语就是<code>token</code>。</p><figure class="highlight ruby"><figcaption><span>write token generator on ruby</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Racket</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(str)</span></span></div><div class="line">        str.gsub(<span class="string">"("</span>, <span class="string">"( "</span>) <span class="comment"># add space after '('</span></div><div class="line">           .gsub(<span class="string">")"</span>, <span class="string">" )"</span>) <span class="comment"># add space before ')'</span></div><div class="line">           .split(<span class="string">" "</span>) <span class="comment"># split string into an array(tokens) base on whitespaces</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>快速简介下ruby，本文在前言里面提及了面向新手，所以会对于不了解ruby的读者涉及一些介绍，<strong>这部分内容我会用引言块注明（如下），如果不需要，随意跳过。</strong> 不光会有ruby知识，还有一些别的编程知识。</p><blockquote><p>Ruby是一种<code>动态类型dynamic type</code> <code>面向对象object oriented</code>编程语言。我定义了一个名叫Racket的<code>类class</code>。 其中定义了一个名叫tokenize的函数。函数有一个’str’的参数，用来接收代码字符串。注意class和method都使用了end明确表明各自代码块的结束部分，ruby里面大部分代码快都需要end结尾，比如if。<br>另外ruby函数会自动返回最后一个对象。当然你也可以明确<em>explicitly</em>使用<code>return</code>，比如条件（if）分支需要返回的情形。</p></blockquote><p>代码很简单，先将这对括号“()”内测增加一个空格，方便最后<code>分割split</code>操作。<code>gsub</code>便是替换操作。</p><blockquote><p><code>str.gsub(...).gsub(...).split(...)</code>这种连着执行函数模式，术语叫做<em>chaining</em>。自己写的代码函数返回对象即可做到。<br>另外这种风格并不是ruby或者别的某个语言特有的，是一种<code>习惯用法idiom</code>。好处就是少些变量名或者赋值，另外也没必要构造一个大而全方法，完全可以构建更合理多个方法并连续调用从而达到目标。</p></blockquote><p>下面便测试下上述代码 使用系统的命令行工具到相应的代码目录。确保安装ruby后输入<code>irb</code>命令，定义一段代码string，传入<code>tokenize</code>函数生成token。 <figure class="highlight irb"><figcaption><span>Test Tokenize</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">c:</span>\Projects\RacketOnRuby&gt;irb</div><div class="line"><span class="meta">irb(main):001:0&gt;</span> load <span class="string">'racket.rb'</span></div><div class="line">=&gt; true</div><div class="line"><span class="meta">irb(main):002:0&gt;</span> r = Racket.new</div><div class="line">=&gt; #&lt;Racket:0x00000002e67df8&gt;</div><div class="line"><span class="meta">irb(main):003:0&gt;</span> str = <span class="string">%&#123;(+ 1</span></div><div class="line">irb(main):004:0"      (* 2</div><div class="line">irb(main):005:0"         (- 7 3)))</div><div class="line">irb(main):006:0" &#125;</div><div class="line">=&gt; <span class="string">"(+ 1\n     (* 2\n        (- 7 3)))\n"</span></div><div class="line"><span class="meta">irb(main):007:0&gt;</span> p r.tokenize(str)</div><div class="line">[<span class="string">"("</span>, <span class="string">"+"</span>, <span class="string">"1"</span>, <span class="string">"("</span>, <span class="string">"*"</span>, <span class="string">"2"</span>, <span class="string">"("</span>, <span class="string">"-"</span>, <span class="string">"7"</span>, <span class="string">"3"</span>, <span class="string">")"</span>, <span class="string">")"</span>, <span class="string">")"</span>]</div><div class="line">=&gt; [<span class="string">"("</span>, <span class="string">"+"</span>, <span class="string">"1"</span>, <span class="string">"("</span>, <span class="string">"*"</span>, <span class="string">"2"</span>, <span class="string">"("</span>, <span class="string">"-"</span>, <span class="string">"7"</span>, <span class="string">"3"</span>, <span class="string">")"</span>, <span class="string">")"</span>, <span class="string">")"</span>]</div></pre></td></tr></table></figure></p><blockquote><ul><li>第1行（最左边的行号）<code>irb</code>进入ruby REPL。没听过REPL，先粗略认为REPL就是专门执行代码的命令工具。下文<a href="#工具repl-read-eval-print-loop">REPL章节</a>会详细的涉及，因为我们实现Racket也要写个Racket的REPL，来方便测试。</li><li>第2行加载包含Racket class的相应的ruby file。 我的ruby文件名就叫做racket.rb。</li><li>第4行创建一个Racket的对象<code>实例instance</code>。该实例将来调用相应的函数进行<code>tokenize</code>以及后续的操作。Ruby的语法syntax，很多时候执行函数都可以省略括号，比如此处创建对象的时候调用<code>new</code>构造函数，可选写法：<code>Racket.new()</code>两种代码等价的。</li><li>6行到9行，定义了变量名为<code>str</code>的code string。 <code>%{...}</code>是ruby定义多行字符串的一种语法syntax。</li><li>第10行，irb会自动输出之前代码执行结果返回的对象（包括之前的3、5行）。其中把换行转义成了’’输出在一行。</li><li>第11行，调用<code>tokenize</code>函数，并传入上一步定义的string。并打印输出结果即tokens</li></ul></blockquote><blockquote><p>可以把上述命令行中的ruby测试代码放入专门的rb文件，这样就无需在每次重新测试再敲代码。例如github项目中的<em>example.rb</em>，直接系统命令行执行<code>ruby example.rb</code></p></blockquote><p>此前代码，在<code>tokenize</code>函数多了第一步处理是把多个空白符转化成单个隔空&quot; “，然而写这篇文章的时候，我重新审查了下代码，并不需要多此一举。多余的代码：<code>str.gsub(/\s{2,}/, &quot; &quot;)</code></p><p>原因是<code>split</code>方法传入单个空格字符串的时候，会基于空白符<em>whitespace</em>分割，而且会忽略余下的紧挨着的空白符。<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p><p>token生成好了，下面便是分析token并生成AST了。</p><h2 id="abstract-syntax-tree-parse-tree">Abstract Syntax Tree (Parse Tree)</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_ast</span><span class="params">(tokens)</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">aux</span><span class="params">(tokens, acc)</span></span></div><div class="line">        <span class="keyword">if</span> tokens.empty?</div><div class="line">            <span class="comment"># no tokens left, return result</span></div><div class="line">            <span class="keyword">return</span> acc</div><div class="line">        <span class="keyword">end</span></div><div class="line"></div><div class="line">        token = tokens.shift <span class="comment"># get first token</span></div><div class="line">        <span class="keyword">if</span> <span class="string">'('</span> == token <span class="comment"># start one s-expression</span></div><div class="line">            sub_ast = aux tokens, []</div><div class="line">            acc.push sub_ast</div><div class="line"></div><div class="line">            aux(tokens,  acc) <span class="comment"># recursive call to continue handling rest tokens</span></div><div class="line">        <span class="keyword">elsif</span> <span class="string">')'</span> == token <span class="comment"># end one s-expression</span></div><div class="line">            <span class="keyword">return</span> acc</div><div class="line">        <span class="keyword">else</span></div><div class="line">            acc.push atom(token) <span class="comment"># convent current token to atom</span></div><div class="line">            aux tokens, acc <span class="comment"># recursive</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    aux tokens, [] <span class="comment"># initial call helper</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>真正起作用的是<code>generate_ast</code>内部定义<code>aux</code>（<em>auxiliary辅助</em>, <em>helper</em>）的方法，处理tokens，其参数<code>acc</code>（<em>accumulator累加器</em>）存放的处理得到的AST。</p><p>主要使用<code>递归 recursion</code>从左到右处理<code>tokens</code>里面的每一个token：</p><ul><li>tokens为空的时候，返回<code>acc</code>即AST结果。</li><li>当遇到左括号时，说明遇到一个s-expression的序列，递归调用<code>aux</code>方法的时候给<code>acc</code>参数传入一个新的空array（上述第10行代码），用来存储这部分subdivision s-expression序列对应的AST结果。<br>第11行，递归调用处理完返回<code>subdivision acc</code>结果，追加到原来acc后面。</li><li>当遇到右括号的时候，说明s-expression的结束，返回结果<code>acc</code>，对应上一点的<code>subdivsion acc</code>。<br></li><li>剩余其他情况，将token转化为atom，紧接的下文涉及atom实现细节。</li></ul><p>实际<code>generate_ast</code>方法简化下就是匹配括号的代码，包括嵌套<em>nested</em>结构。</p><blockquote><p>上述代码并没有检测括号是否匹配，因为需要文章简洁，这里只贴出不检测括号的代码，github上面的源文件里面包含有完整的括号检测。<br>racket里面除了可以使用圆括号()，也可以使用方括号[]，两者功能作用没有区别，编码习惯在某些地方会使用[]，但不遵循也不会有什么实质影响。唯一注意的就是要对应的括号匹配，不能混用，比如<code>(+ 1 1]</code>就是语法不正确。</p></blockquote><h3 id="atom">Atom</h3><figure class="highlight ruby"><figcaption><span>s-expression atom</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">atom</span><span class="params">(token)</span></span></div><div class="line">    str_part = token[<span class="regexp">/^"(.*)"$/</span>, <span class="number">1</span>] <span class="comment"># try match string(start and end with ")</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> str_part.<span class="literal">nil</span>?</div><div class="line">        str_part</div><div class="line">    <span class="keyword">elsif</span> token[<span class="regexp">/(?=(\.|[eE]))(\.\d+)?([eE][+-]?\d+)?$/</span>]  <span class="comment"># decimal</span></div><div class="line">        token.to_f</div><div class="line">    <span class="keyword">elsif</span> token[<span class="regexp">/^\d+$/</span>] <span class="comment"># integer</span></div><div class="line">        token.to_i</div><div class="line">    <span class="keyword">else</span> <span class="comment"># symbol</span></div><div class="line">        token.to_sym</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>刚才上文我们已经处理了s-expression序列，即<a href="#racket所有的东西都是">上文提及s-expression</a>第二种情形。此处<code>atom</code>为第一种情况，具体又有细分，可能是string、数字、也有可能是<code>identifier</code>。对应代码中<code>if</code>语句各个分支，通过正则式尝试匹配<code>token</code>（Ruby string对象）：</p><ol style="list-style-type: decimal"><li>在Racket中头尾各一个双引号<code>&quot;</code>来包含字符串。第一个if便是通过正则式匹配首尾“，如果的确是string，其中间部分取出就是对应的Ruby string类型的对象。</li><li><p>第二个if分支判断是否为浮点数。这里的正则式看起来很复杂，简单代替方案是仅仅匹配小数点（正则式为 <code>/\.\d+$/</code>）。这里复杂的正则式是除了用来匹配小数外，还能匹配指数<em>exponential</em>，Ruby中指数类似1e5也算作浮点数(等同于10000.0，Racket中也是同样的)。to_f便是将string转化为float浮点数的方法。这里举出4个数<code>.003</code> <code>0.5</code> <code>32e3</code> <code>.24e5</code>，这些都是浮点数，我们的正则式便是能够匹配出对应小数点部分以及指数部分，测试代码如下，第一行这四个数尝试使用该正则式匹配，第二行是匹配部分的结果: <figure class="highlight ruby"><figcaption><span>decimal and exponential</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'.003'</span>, <span class="string">'0.5'</span>, <span class="string">'32e3'</span>, <span class="string">'.24e5'</span>].map&#123;<span class="params">|num|</span> num[<span class="regexp">/(?=(\.|[eE]))(\.\d+)?([eE][+-]?\d+)?$/</span>] &#125;</div><div class="line"><span class="comment"># =&gt; [".003", ".5", "e3", ".24e5"]</span></div></pre></td></tr></table></figure></p><blockquote><p>Ruby Array的map方法，是将其中每个元素都进行block中处理。 <code>{ |num| ...}</code>形式就是block，此处Array.map会往block的num参数 传入单个元素。</p></blockquote></li><li>第三个if分支，尝试匹配是否为整数。to_i便把string是转化整数<em>integer</em>的方法</li><li><p>最后一个else分支，剩下情况可能是变量名或者special form比如<code>lambda</code> <code>define</code>等。最后转化为Ruby <code>符号Symbol</code>类型。所谓symbol类似string，symbol为不可变<code>immutable</code>，而且其值一样的话，就是同一个对象。</p><blockquote><p>Ruby中symbol是以<code>:</code>作为开头，例如<code>:hello</code>。两两比对的时候symbol效率更高。不像string一个一个字符<em>char</em>进行比对，symbol直接比对两者在内存中是否为同一个对象。</p></blockquote></li></ol><p>到此为止，实现了生成AST的部分，下面就要涉及interpreter部分了。</p><h2 id="eval方法实现executorinterpreter">eval方法实现executor(interpreter)</h2><p>有些表达式<em>expression</em>中会包含变量<em>variable</em>，求值<em>evaluate</em>这些表达式就需要<code>environment</code>，通过variable获得对应值<em>vaLue</em>。</p><p>environment的实现是<code>metalanguage</code>的一部分，metalanguage这里就是我们使用的Ruby。这里使用hash数据结构来代表environment。</p><h3 id="完成代数运算eval">完成代数运算eval</h3><p>文章一开始的提及的代数运算的Racket代码<code>(+ 1 (* 2 3))</code>，首先将其实现: <figure class="highlight ruby"><figcaption><span>eval algebra operators</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">()</span></span></div><div class="line">    @env = &#123;</div><div class="line">        <span class="symbol">:+</span> =&gt; lambda&#123;<span class="params">|x, y|</span> x+y&#125;,</div><div class="line">        <span class="symbol">:*</span> =&gt; lambda&#123;<span class="params">|x, y|</span> x*y&#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(exp, env=@env)</span></span></div><div class="line">    <span class="keyword">if</span> exp.is_a? Numeric</div><div class="line">        exp <span class="comment"># is a number(integer and float) return itself</span></div><div class="line">    <span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:+</span> <span class="keyword">or</span> exp[<span class="number">0</span>] == <span class="symbol">:*</span></div><div class="line">        env[ exp[<span class="number">0</span>] ].call( eval(exp[<span class="number">1</span>], env), eval(exp[<span class="number">2</span>], env) )</div><div class="line">    <span class="keyword">else</span></div><div class="line">        results = exp.map &#123; <span class="params">|subexp|</span> eval(subexp, env) &#125;</div><div class="line">        results[-<span class="number">1</span>]</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>增加了两个方法<code>initialize</code>以及<code>eval</code>。</p><blockquote><p><code>initialize</code>方法是Ruby的对象的构造器方法，即<code>new</code>对象时候会调用该方法，该方法可以省略，我们之前<code>parser</code>部分就不需要构造方法，所以就一直没有<code>initialize</code>。</p></blockquote><blockquote><p>Ruby中<code>@</code>开头的变量是<code>实例变量instance variable</code>，作用范围为单个对象实例内，所有该对象的内部方法都可以访问到。<br>另外<code>@@</code>两个at符号开头是<code>类变量class variable</code>，顾名思义即同一个类创建的所有对象实例 都共享同一个类变量。<br>Ruby<strong>不需要提前声明variable</strong>，赋值一个之前不存在的variable，会自动创建该variable。</p></blockquote><p>其中<code>initialize</code>方法中，定义了一个<code>@env</code>实例变量，并赋值了一个hash。之前说过，在Racket中代数运算看作函数，metalanguage(Ruby)实现了<code>+</code>和<code>*</code>各自对应的lambda（或者叫Proc object，ruby的术语），lambda可以看作匿名函数，该匿名函数接受两个参数<code>x``y</code>，将其相加或者相乘。</p><p>后文还会详细介绍lambda，因为我们也要实现Racket的lambda，Racket和Ruby的lambda基本是同一个东西，仅语法有区别。</p><p>eval方法依旧含有recursive call，递归很适合处理嵌套形式，处理 子表达式<em>subexpression</em>，需要返回的情形结果可能有差异。</p><ul><li>第一个if条件分支，判断如果表达式只是纯粹数字，那么不需要额外处理，返回自身。</li><li>第二个条件分支，涉及expression的首个thing如果是<code>:+</code>或者<code>:*</code>，<code>env[ exp[0] ]</code>则去environment中查找对应的函数。调用传入expression紧接着的2个thing，作为两个操作数。注意此处都会先执行下eval方法，因为可能是需要处理的subexpression，同时也是使用的同样的environment。</li><li>最后一个条件分支，之前实现的parser实际上可以处理多个expression，例如<code>(+ 1 1) (* 2 2) (+ 3 4)</code>这样的代码中包含三个expression，parser处理完后的AST为<code>[[:+, 1, 1], [:*, 2, 2], [:+, 3, 4]]</code>，包含三个expression处理后的AST的array。即使只有一个expression，parser处理后也是一个长度为1的array，例如该章开始提到的代码，parse后的结果：<code>[ [:+ 1 [:* 2 3]] ]</code>。<br>这里，我返回的最后一个结果。当然也可以直接放回<code>results</code>结果array。自己写的interpreter，细节由自己定义。</li></ul><h3 id="function-call以及variables-in-environment">Function call以及Variables in environment</h3><p>上面处理加和乘，可以改写成处理任何方法的通用办法. <figure class="highlight ruby"><figcaption><span>updated call functions</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_expressions</span><span class="params">(exps, env=@env)</span></span></div><div class="line">    results = exps.map &#123; <span class="params">|one_exp|</span> eval(one_exp, env) &#125;</div><div class="line">    results[-<span class="number">1</span>]</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(exp, env=@env)</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lookup_env</span><span class="params">(env, var)</span></span></div><div class="line">        error_no_var = <span class="string">"undefined: \"%s\""</span> % var</div><div class="line">        val = env[var]</div><div class="line"></div><div class="line">        <span class="keyword">if</span> val.<span class="literal">nil</span>?</div><div class="line">            raise error_no_var</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> exp.is_a? Numeric</div><div class="line">        exp <span class="comment"># is a number(integer and float) return itself</span></div><div class="line">    <span class="keyword">elsif</span> exp.is_a? Symbol</div><div class="line">        lookup_env(env, exp)</div><div class="line">    <span class="keyword">else</span></div><div class="line">        operator = eval(exp[<span class="number">0</span>], env) <span class="comment"># first thing of s-expression sequence.</span></div><div class="line">        operands = exp[<span class="number">1</span>..-<span class="number">1</span>].map &#123;<span class="params">|sub_exp|</span> eval(sub_exp, env) &#125; <span class="comment"># the rest things of sequence</span></div><div class="line">        operator.call *operands</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>将处理多个expression的办法提炼成<code>eval_expressions</code>方法。这样的话parse处理完后的AST(结果都是array，一个或多个expression)就先调用<code>eval_expressions</code>处理。而<code>eval</code>只用来处理单个expression。这样处理的理由，如果包含在<code>eval</code>一个条件分支的话，会与单个expression处理混乱（因为同样使用array来存放s-expression）。</p><p><code>else</code>分支就是处理方法调用，expression第一个thing也执行了<code>eval</code>。这样就可以处理这样的<code>( (if #t + *) 2 3 )</code>Racket代码（第一个thing也可能是sub expresion）。</p><blockquote><p><code>operator.call *operands</code>中<code>oprands</code>是array，其前面<code>*</code>是<code>splat operator</code>。作用是将数组拆开，每个元素对应到单个参数。反过来，在函数参数声明时候也可以使用<code>*</code>，作用也是相反的，将传入的单个参数值组成array。</p></blockquote><p>另外，多了处理symbol atom的步骤，一般symbol为variable的时候，就需要到environment查找对应的value，即<code>lookup_env</code>方法。该方法很简单，就是通过variable作为key查找environment对应的值，没有variable的话就抛出一个简单错误提示该variable没被定义。</p><p>如果完整代数运算，除法和减法<code>:/</code>，<code>:-</code>可以类似上面写法。但是重复劳动了，用程序来做重复的事。另外还有一点需要改进，Racket中代数运算符，可以接受多个数字，进行累积运算。<br>例如<code>(+ 1 4 5 7)</code>执行结果为<code>17</code>，<code>(* 2 3 4)</code>执行结果为<code>24</code>。 <figure class="highlight ruby"><figcaption><span>updated algebra</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ALGEBRA_OPERATORS = [<span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:*</span>, <span class="symbol">:/</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">()</span></span></div><div class="line">    @env = &#123;</div><div class="line">    &#125;</div><div class="line">    ALGEBRA_OPERATORS.map <span class="keyword">do</span> <span class="params">|opt|</span></div><div class="line">        @env[opt] = lambda&#123; <span class="params">|*operands|</span> operands.inject(opt) &#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>改写成上述代码，通过程序往environment增加每个代数运算符对应的lambda函数。看到这似乎炫技嫌疑，但实际后面也有相同的思想的实现，比较大小的comparison operator也是类似的（也是能接受多个参数）</p><p>至此<code>eval</code>的大致结构功能如此。后文涉及的新的Racket feature，就是往<code>eval</code>增加更多情况的处理，方式可能是增加条件分支，也有可能是往environment中增加函数（可以看作Racket自带的函数）。</p><h3 id="工具repl-read-eval-print-loop">工具REPL, Read-Eval-Print-Loop</h3><p>在继续完备eval方法之前，首先实现REPL这个工具，让调试Racket代码更加方便。就如之前执行Ruby代码的<code>irb</code>。 REPL全称read-eval-print-loop顾名思义，其过程: 读取code -&gt; eval求值这段代码 -&gt; 输出结果 -&gt; 循环上述步骤。 <figure class="highlight ruby"><figcaption><span>REPL</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">(prompt=<span class="string">'RacketOnRb &gt;&gt;'</span>, output_prompt=<span class="string">"=&gt;"</span>)</span></span></div><div class="line">    <span class="keyword">while</span> <span class="literal">true</span></div><div class="line">        print prompt</div><div class="line">        code = gets</div><div class="line"></div><div class="line">        <span class="keyword">begin</span></div><div class="line">            ast = parse(code)</div><div class="line">            result = eval_expressions(ast)</div><div class="line">            puts output_prompt + result.to_s</div><div class="line">        <span class="keyword">rescue</span> Exception =&gt; e</div><div class="line">            puts e</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>相当直接的代码，一个无限循环，接受console输入Racket代码，然后解析执行代码，即之前描述的过程。<br>执行<code>parse</code>，<code>eval</code>这部分时，会尝试捕获异常，如果有异常只是打印出来，继续loop。这样就能避免出错整个program终止，需要重新执行该repl方法。</p><h3 id="定义变量variable">定义变量variable</h3><p>前面已经完成查询variable对应的value的方法。相应我们需要实现定义变量，其语法<code>(define &lt;var&gt; &lt;exp&gt;)</code>。 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:define</span></div><div class="line">    <span class="number">_</span>, var, value_exp = exp</div><div class="line">    env[var] = eval( value_exp, env )</div></pre></td></tr></table></figure></p><p>放置于处理function call分支之前即可。</p><h3 id="条件判断if语句">条件判断、if语句</h3><p>Racket中用<code>#t</code>和<code>#f</code>表示true和false。</p><p>Racket if的语法：<code>(if &lt;test-exp&gt; &lt;then-exp&gt; &lt;else-exp&gt;)</code>当<test-exp>执行结果不是<code>#f</code>的时候，执行<code>&lt;then-exp&gt;</code>分支，否则执行<code>&lt;else-exp&gt;</code>分支 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@env = &#123;</div><div class="line">    <span class="symbol">:<span class="string">'#t'</span></span> =&gt; <span class="literal">true</span>,</div><div class="line">    <span class="symbol">:<span class="string">'#f'</span></span> =&gt; <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="comment"># ...</span></div><div class="line"><span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:if</span></div><div class="line">    <span class="number">_</span>, test_exp, then_exp, else_exp = exp</div><div class="line">    <span class="keyword">if</span> eval(test_exp, env) == <span class="literal">false</span></div><div class="line">        eval( else_exp, env )</div><div class="line">    <span class="keyword">else</span> <span class="comment"># other than false(#f)</span></div><div class="line">        eval( then_exp, env)</div><div class="line">    <span class="keyword">end</span></div></pre></td></tr></table></figure></test-exp></p><p>ruby注释使用<code>#</code>，如果symbol含有#的话，需要用引号括起来。这里会把Racket的<code>#t #f</code>转化为Ruby中的true和false。</p><h3 id="比较操作comparison-operators">比较操作comparison operators</h3><p>至于比较操作，上文提过了类似代数操作实现。 当有多个需要比较的对象时，比较操作需要两两比较，所有两两比较结果为true，则返回true，否则false。 <code>each_cons(n)</code>就是(Ruby提供方法来遍历连续<em>consecutive</em>的n个元素)。<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <figure class="highlight ruby"><figcaption><span>comparision</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">COMPARISION = [<span class="symbol">:==</span>, <span class="symbol">:</span>!=, <span class="symbol">:&lt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:&gt;=</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">()</span></span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">    COMPARISION.map <span class="keyword">do</span> <span class="params">|opt|</span></div><div class="line">        @env[opt] = lambda&#123; <span class="params">|*args|</span> args.each_cons(<span class="number">2</span>).all? &#123;<span class="params">|x, y|</span> x.method(opt).call(y)&#125; &#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>Ruby和其他大部分语言，使用<code>=</code>代表赋值操作，所以比较是否相等时候使用<code>==</code>。但是Racket有专门的<code>define</code>操作，所以依旧使用<code>=</code>代表比较是否相等的函数。<br>我追求简单，所以实现套用Ruby语法。如果要改为Scheme Racket语法也很简单，多做一次符号映射即可，其他不做赘述了。</p><h3 id="cons-cell-and-list">Cons Cell and List</h3><p><code>cons</code>操作用来构建一个pair，其通过<code>car</code>获得pair的第一个数据，通过<code>cdr</code>获得pair的第二个数据，pair有专门的术语：<code>cons cell</code>。</p><p>另外Racket有个特许且常用的<code>cons cell</code>形式：<code>list</code>，例如<code>(cons 1 (cons 2 (cons 3 (cons 4 null))))</code>代码，nested cons cells，最后一个（最内部的pair）的第二数据以<code>null</code>为结尾。<br><code>null</code>在Racket中代表空list，<code>null?</code>判断是否为空的函数。list有个更加简便的写法<code>(list 1 2 3 4)</code>等同上行的代码例子。</p><table><colgroup><col width="17%"><col width="40%"><col width="41%"></colgroup><thead><tr class="header"><th align="left">Primitive</th><th align="left">Description</th><th align="left">Example</th></tr></thead><tbody><tr class="odd"><td align="left">null</td><td align="left">The empty list</td><td align="left">null</td></tr><tr class="even"><td align="left">cons</td><td align="left">Construct a list</td><td align="left">(cons 2 (cons 3 null))</td></tr><tr class="odd"><td align="left">car</td><td align="left">Get rst element of a list</td><td align="left">(car some-list)</td></tr><tr class="even"><td align="left">cdr</td><td align="left">Get tail of a list</td><td align="left">(cdr some-list)</td></tr><tr class="odd"><td align="left">null?</td><td align="left">Return #t for the empty-list and #f otherwise</td><td align="left">(null? some-value)</td></tr></tbody></table><p>对于Ruby实现代码，我们使用array来存放<code>cons cells</code>，固定两个元素。</p><p>对于<code>list</code>函数实现，依旧采用recursion方式，cons（直接构造Ruby array）第一个参数以及余下参数构成的list，很直白实现方式。</p><figure class="highlight ruby"><figcaption><span>cons cells</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">:null?</span> =&gt; lambda &#123; <span class="params">|exp|</span> <span class="symbol">:null</span> == exp &#125;, <span class="comment"># racket empty list.</span></div><div class="line"><span class="symbol">:cons</span> =&gt; lambda &#123; <span class="params">|x, cell|</span> [x, cell] &#125;,</div><div class="line"><span class="symbol">:car</span> =&gt; lambda &#123; <span class="params">|cell|</span> cell[<span class="number">0</span>]&#125;,</div><div class="line"><span class="symbol">:cdr</span> =&gt; lambda &#123; <span class="params">|cell|</span> cell[<span class="number">1</span>] &#125;,</div><div class="line"><span class="symbol">:list</span> =&gt; lambda <span class="keyword">do</span> <span class="params">|*args|</span></div><div class="line">    <span class="comment"># racket code '(list 1 2 3)' is equivalent to '(cons 1 (cons 2 (cons 3 null)))'</span></div><div class="line">    racket_list_helper= lambda <span class="keyword">do</span> <span class="params">|args|</span></div><div class="line">        <span class="keyword">if</span> args.empty? <span class="keyword">then</span> <span class="symbol">:null</span></div><div class="line">        <span class="keyword">else</span> [args[<span class="number">0</span>], racket_list_helper.call(args[<span class="number">1</span>..-<span class="number">1</span>])]</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    racket_list_helper.call(args)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><!-- TODO: map, filter, fold --><h3 id="functionslambda-and-apply">Functions，Lambda and Apply</h3><blockquote class="pullquote has-quotes"> <!-- TODO: pullquote style -->问题弄清楚后，答案自然就清楚了。</blockquote><p>到了我觉得最重要的function部分了。目标实现function，只需要搞清楚何为function就知道如何实现，首先先要明确一些相关的概念。</p><p>Racket的函数遵循<code>lexical scope</code>又称作<code>static scope</code>，函数的正文部分求值时，所用的environment在该函数被定义时候的enviroment。相对立的<code>dynamic scope</code>，就是函数求值时，使用的函数被调用的enviroment。</p><blockquote><p>The body of function is evaluated in the environment when the function is <strong>defined</strong>, not the environment when the function is <strong>called</strong>.</p></blockquote><p>现在主流编程语言基本都是使用<code>lexical scope</code>，程序行为更可控。</p><p>除了定义的时候的environment，方法执行的时候，还会将该environment扩展添加参数<em>parameters</em>以及其对应传入的值<em>arguments</em>。</p><p>function(或者叫lambda, procedure)的实现代码如下，存放lambda的parameters和body，以及定义时候的envrioment，就如同上文描述那样。</p><p>定义了Closure class，只是用来存放closure的值。也可以用数组<code>[:closure, parameters, body, env]</code>存放，通过index取值，但是这样的话<code>:closure</code>可以被覆盖。</p><p>真正执行部分，处于之前执行方法部分，之前处理例如加法之类的primitive procedures。现在增加分支专门处理，用户定义的函数<em>compound procedures</em>。 操作数部分与之前一样，先eval，然后补充进函数定义时的environment。该environment为执行函数体<em>body</em>的环境，然后求值。</p><figure class="highlight ruby"><figcaption><span>closure</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Closure</span></span></div><div class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:parameters</span>, <span class="symbol">:body</span>, <span class="symbol">:env</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(parameters, body ,env)</span></span></div><div class="line">        @parameters = parameters</div><div class="line">        @body = body</div><div class="line">        @env = env</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(exp, env)</span></span></div><div class="line">    <span class="comment"># ... other part code</span></div><div class="line">    <span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:lambda</span></div><div class="line">        <span class="number">_</span>, parameter_names, fun_body = exp</div><div class="line">        Closure.new(parameter_names, fun_body, env)</div><div class="line">    <span class="comment"># ... other part code</span></div><div class="line">    <span class="keyword">else</span> <span class="comment"># call function</span></div><div class="line">        operator = eval(exp[<span class="number">0</span>], env) <span class="comment"># first thing of s-expression sequence.</span></div><div class="line">        operands = exp[<span class="number">1</span>..-<span class="number">1</span>].map &#123;<span class="params">|sub_exp|</span> eval(sub_exp, env) &#125; <span class="comment"># the rest things of sequence</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> operator.is_a? Closure <span class="comment"># compounded procedures(user-defined)# extends environment with parameters and their actual arguments applied.</span></div><div class="line"></div><div class="line">            env_fn = operator.parameters.zip(operands) + operator.env</div><div class="line">            body = operator.body</div><div class="line">            eval(body, env_fn)</div><div class="line">        <span class="keyword">else</span> <span class="comment"># primitive operators</span></div><div class="line">            operator.call *operands</div><div class="line">        <span class="keyword">end</span></div></pre></td></tr></table></figure><p>另外environment有了较大的改动，之前使用hash结构，在写这篇文章的时候，我重新审查代码时候，发现有较大缺陷：</p><ul><li>之前hash结构，define定义新变量是直接更改该hash本身，mutation操作。定义lambda的时候，最初直接传入env本身，然而因为hash是可变的，所以实现的是<code>dynamic scope</code>方式，后续对env操作也会影响函数定义是当前的env(就是同一个对象)。</li><li>我最初的处理方法是，对于函数定义时候的env，使用一个新的对象<code>env.clone</code>。似乎解决了问题，但是在某些simultaneous同时发生，比如需要两个方法同时定义，如果通过<code>env.clone</code>，两个方法的env是两个独立对象，然而我们需要两个方法env都是同一个对象，因为它们处于并列状态，例如<code>letrec</code>（不是本文重点，但代码中有实现）。</li></ul><p>所以，需要改变的是：</p><ul><li>define添加新的variable到当前env（并不改变原先env）作为新的env。相当于新的environment是immutable。</li><li>定义lambda的时候，直接使用当前的env。</li></ul><div class="figure"><img src="/images/2017-RacketOnRuby/closure-env.jpg" alt="the environment of the closure"><p class="caption">the environment of the closure</p></div><p>对应到ruby代码实现。使用array取代hash，其中每个元素即变量和其对应的值（2个元素的array分别存variable,value）。 define时候通过 <code>env[0..-1]</code> 重新赋值env。由于现在需要直接更改当前的environment，而且ruby不支持参数传入引用，所以我使用<code>env[0..-1] = [new array]</code>将env内的array中的元素替换成新的env（包含新定义的variable），来达到更改当前environment目的。</p><figure class="highlight ruby"><figcaption><span>new environment\</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@env = [</div><div class="line">    [<span class="symbol">:<span class="string">'#t'</span></span> ,  <span class="literal">true</span>],</div><div class="line">    [<span class="symbol">:<span class="string">'#f'</span></span> ,  <span class="literal">false</span>],</div><div class="line">    <span class="comment"># Racket 'not' operator if exp is #f, results #t. otherwise false. it differents from ruby not</span></div><div class="line">    [<span class="symbol">:not</span> ,  lambda &#123; <span class="params">|exp|</span> <span class="keyword">if</span> <span class="literal">false</span>==exp <span class="keyword">then</span> <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span> <span class="keyword">end</span> &#125;],</div><div class="line">    <span class="comment"># ... other primitive procedures.</span></div><div class="line">    ]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(exp, env=@env)</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lookup_env</span><span class="params">(env, var)</span></span></div><div class="line">        error_no_var = <span class="string">"undefined: %s !"</span> % var</div><div class="line">        var_val = env.assoc var</div><div class="line"></div><div class="line">        <span class="keyword">if</span> var_val.<span class="literal">nil</span>?</div><div class="line">            raise error_no_var</div><div class="line">        <span class="keyword">elsif</span> var_val[<span class="number">1</span>] == UNASSIGNED_VAL</div><div class="line">            raise <span class="string">"the unassigned value should not be access."</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> var_val[<span class="number">1</span>]</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    <span class="comment"># ... other eval parts</span></div><div class="line">    <span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:define</span></div><div class="line">        <span class="number">_</span>, var, value_exp = exp</div><div class="line"></div><div class="line">        value = eval( value_exp, env )</div><div class="line">        env[<span class="number">0</span>..-<span class="number">1</span>] = [[var , value]] + env</div><div class="line">    <span class="comment"># ... other eval parts</span></div><div class="line"><span class="keyword">end</span> <span class="comment"># eval</span></div></pre></td></tr></table></figure><p>至此，最重要的lambda部分就已经完成实现了。</p><h2 id="racketonruby总结">RacketOnRuby总结</h2><p>出于练习目的，实现Racket的一个解析器。从功能完整性和性能考虑，并不适合实际生产中运用。</p><p>得益于Racket语法统一简单，实现也相对简单。不像很多别的语言，有大量不同形式的语法。</p><ul><li>相对于原生Racket，肯定缺少一些功能，但常见的基本都实现了。<ul><li>实现了environment、variable、condition(if)、 lambda、 cons cells、 list、 一些primitive procedures(代数运算，数值比较)。</li><li>语法缺少的：注释<em>comment</em>、 quote、 # symbol(字面量类似Ruby symbol)、 一些derived expression(可以转化为现有的别的表达式，例如cond用来多个条件判断，可以转化为嵌套的if)</li><li>项目中代码是实现有<code>let</code>和<code>letrec</code>，也是derived expression。<code>(let ([&lt;var&gt; &lt;exp&gt;]) body)</code>其作用就是绑定local variable，并在其environment执行body部分代码。<code>let</code>可以转为<code>lambda</code>, <code>letrec</code>可以转为一种特殊形式<code>let</code>。转化方法是直接操作AST，由于Ruby中AST用的Array表现，并不是那么清晰，所以不做本文重点。（相对于metalanguage使用Lisp系语言，Lisp系语言code即data，代码部分也可以操作，即可以直接在程序expression上直接操作）</li><li>缺少大量primitive procedures，语言肯定会有大量自带的函数，不可能一一实现。其中之一就是mutation list，Racket的默认list是不可变的immutable。如果需要可变的，有专门的操作:<code>mcons</code>，<code>set-mcar!</code>, <code>set-mcdr!</code>。这一点也是Racket与Scheme不同的一处，Scheme中list是mutation list。</li><li>error handling不是主要目标，所以几乎没有异常错误处理，所以需要执行的program先要保证正确的。可以DrRacket先执行一遍，尤其括号方面（多或者少，不匹配），IDE可以很明显看出括号范围。</li></ul></li><li>性能方面，也不是主要目标，没有特别优化。下面指出一些可以改进的地方：<ul><li><p><code>eval</code>实现，实际上语义分析<em>syntactic analysis</em>夹杂在执行<em>execution</em>之中，不是有效率的做法。如下阶乘的program，当执行<code>(factorial 5)</code>，递归调用<code>factorial</code>多次，其中<code>if</code>部分每次都需要判断出是<code>if</code>，但执行到<code>(* (factorial (- n 1)) n)))</code>其中<code>(- n 1)</code>和<code>(factorial (- n 1))</code>都需要在<code>eval</code>判断出是方法执行然后再处理。非常重复浪费的做法，需要将analysis分离出来，本文并没涉及，具体实现可以参考SICP<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>第四大章中<em>Separating Syntactic Analysis from Execution</em>小节部分 <figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial</span> n)</div><div class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>)</div><div class="line">        <span class="number">1</span></div><div class="line">        (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)) n)))</div></pre></td></tr></table></figure></p></li><li><p>缺少<code>TCO</code><em>tail call optimization</em>，尾递归优化，Lisp和Scheme系的语言program非常依赖与递归调用，TCO非常重要，能省去很多function call占用的stack空间。</p></li></ul></li></ul><p>要想了解interpreter如何工作，最好办法就是自己实现一个了，这就是我实现RacketOnRuby以及写本文的目的。 如果需要更深入了解，推荐上文提及SICP以及另外一本书TSPL<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>，都是有免费阅读的电子版。或者自行搜索，有相当多的资料。</p><p>另外文章最开始提及的《黑客与画家》，非编程技术书，也推荐阅读。语言通俗易懂，不涉及技术细节，阅读不费力，非程序员也能读。但其中作者的思想条理清晰，观点深入透彻。另外本书也不光全是关于Lisp，还有一些有趣事情，我印象较深的就是最开始的章节“为什么书呆子不受欢迎”。</p><!-- toc --><div class="footnotes"><hr><ol><li id="fn1"><p><a href="https://ruby-doc.org/core-2.4.0/String.html#method-i-split" target="_blank" rel="noopener">Ruby Doc: String.split</a>: If pattern is a String, then its contents are used as the delimiter when splitting str. If pattern is <strong>a single space</strong>, str is split on <strong>whitespace</strong>, with leading whitespace and runs of <strong>contiguous whitespace characters ignored</strong>.<a href="#fnref1">↩</a></p></li><li id="fn2"><p><a href="https://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-each_cons" target="_blank" rel="noopener">Ruby Doc Enumerable each_cons(n)</a>: Iterates the given block for each array of consecutive <n> elements. If no block is given, returns an enumerator.<a href="#fnref2">↩</a></n></p></li><li id="fn3"><p><em>Structure and Interpretation of Computer Programs</em> <a href="https://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank" rel="noopener">MIT scheme课程书籍</a>.<a href="#fnref3">↩</a></p></li><li id="fn4"><p><em>The Scheme Programming Language</em> <a href="http://www.scheme.com/tspl4/" class="uri" target="_blank" rel="noopener">http://www.scheme.com/tspl4/</a>.<a href="#fnref4">↩</a></p></li></ol></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/symbol/lambda.svg&quot; class=&quot;center&quot; width=&quot;200&quot; title=&quot;lambda symbol&quot;&gt;
&lt;p&gt;如果学习Lisp系语言，可能在后期都会实现一个本语言的解释器&lt;code&gt;interpreter&lt;/code&gt;来练个手。&lt;/p&gt;
&lt;p&gt;我学的是 Lisp(或者说Scheme) 方言之一的Racket，自己当时能写解释器的时候的确感觉不一样。&lt;br&gt;
毕竟之前也接触过很多语言，基本都是学的语言特性&lt;code&gt;feature&lt;/code&gt;，和其流行的package使用(比如web框架)。很少接触过语言实现&lt;code&gt;language implemention&lt;/code&gt;的知识。&lt;/p&gt;
&lt;p&gt;当自己能写出解释器的时候，感觉到一种新的学习语言的体验。&lt;/p&gt;
&lt;p&gt;这篇文章努力做到新手友好，只需要有一定编程知识基础(可能只要懂一门语言)即可阅读。&lt;/p&gt;
&lt;p&gt;项目github链接：&lt;a href=&quot;https://github.com/mixflow/RacketOnRuby/&quot; class=&quot;uri&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mixflow/RacketOnRuby/&lt;/a&gt;
    
    </summary>
    
    
      <category term="programming" scheme="http://www.mix-flow.com/tags/programming/"/>
    
      <category term="interpreter" scheme="http://www.mix-flow.com/tags/interpreter/"/>
    
      <category term="racket" scheme="http://www.mix-flow.com/tags/racket/"/>
    
      <category term="ruby" scheme="http://www.mix-flow.com/tags/ruby/"/>
    
      <category term="lambda" scheme="http://www.mix-flow.com/tags/lambda/"/>
    
      <category term="scheme" scheme="http://www.mix-flow.com/tags/scheme/"/>
    
      <category term="lisp" scheme="http://www.mix-flow.com/tags/lisp/"/>
    
      <category term="eval" scheme="http://www.mix-flow.com/tags/eval/"/>
    
  </entry>
  
  <entry>
    <title>UE4作品 简易书房</title>
    <link href="http://www.mix-flow.com/2017/02/17/UE4-work-book-room/"/>
    <id>http://www.mix-flow.com/2017/02/17/UE4-work-book-room/</id>
    <published>2017-02-17T09:53:21.000Z</published>
    <updated>2017-02-18T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>制作软件: Unreal Engine 4</li><li>建模软件: Blender</li></ul><p>这个是我初期学习UE4，并尝试做的作品（2016初），是第一个有可以看的东西的UE4作品。<br>在之前的学习UE4做的东西并不是画面为主，不太适合展示，比如游戏AI。</p><div class="figure"><img src="/images/2016-BookRoom/1.jpg" alt="概览 前厅"><p class="caption">概览 前厅</p></div><a id="more"></a><div class="figure"><img src="/images/2016-BookRoom/2.jpg" alt="前厅 沙发椅"><p class="caption">前厅 沙发椅</p></div><div class="figure"><img src="/images/2016-BookRoom/3.jpg" alt="侧面概览"><p class="caption">侧面概览</p></div><div class="figure"><img src="/images/2016-BookRoom/4.jpg" alt="桌子"><p class="caption">桌子</p></div><div class="figure"><img src="/images/2016-BookRoom/5.jpg" alt="两联窗户"><p class="caption">两联窗户</p></div><div class="figure"><img src="/images/2016-BookRoom/6.jpg" alt="书架&amp;画板"><p class="caption">书架&amp;画板</p></div><div class="figure"><img src="/images/2016-BookRoom/7.jpg" alt="从书房的概览"><p class="caption">从书房的概览</p></div><div class="figure"><img src="/images/2016-BookRoom/8.jpg" alt="楼梯"><p class="caption">楼梯</p></div>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;制作软件: Unreal Engine 4&lt;/li&gt;
&lt;li&gt;建模软件: Blender&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个是我初期学习UE4，并尝试做的作品（2016初），是第一个有可以看的东西的UE4作品。&lt;br&gt;
在之前的学习UE4做的东西并不是画面为主，不太适合展示，比如游戏AI。&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;/images/2016-BookRoom/1.jpg&quot; alt=&quot;概览 前厅&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;概览 前厅&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="my work" scheme="http://www.mix-flow.com/categories/my-work/"/>
    
      <category term="ue4" scheme="http://www.mix-flow.com/categories/my-work/ue4/"/>
    
    
      <category term="CG" scheme="http://www.mix-flow.com/tags/CG/"/>
    
      <category term="UE4" scheme="http://www.mix-flow.com/tags/UE4/"/>
    
      <category term="unreal engine" scheme="http://www.mix-flow.com/tags/unreal-engine/"/>
    
      <category term="work" scheme="http://www.mix-flow.com/tags/work/"/>
    
      <category term="interior" scheme="http://www.mix-flow.com/tags/interior/"/>
    
      <category term="blender" scheme="http://www.mix-flow.com/tags/blender/"/>
    
      <category term="PBR" scheme="http://www.mix-flow.com/tags/PBR/"/>
    
      <category term="3D" scheme="http://www.mix-flow.com/tags/3D/"/>
    
  </entry>
  
</feed>
