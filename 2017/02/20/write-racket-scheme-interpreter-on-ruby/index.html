<!DOCTYPE html>
<html>
  
  <head>
  <meta charset="utf-8">
  
  

  <title>MixFlow「混流」| A programmer and CG artist's personal website</title>
  <meta name="viewport" content="width=device-width initial-scale=1 maximum-scale=1">
  <link rel="alternate" href="/atom.xml" title="MixFlow「混流」| A programmer and CG artist's personal website" type="application/atom+xml">
  <link rel="icon" href="/favicon.png">

  
    <style>
    /* google font for the code. */
    @font-face {
      font-family: 'Source Code Pro';
      font-style: normal;
      font-weight: 400;
      src: local('Source Code Pro'),
           local('Source-Code-Pro-regular'),
           url('/fonts/SourceCodePro-Regular.woff') format('woff'),
           url('/fonts/SourceCodePro-Regular.ttf') format('truetype');
      /*unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215; */
    }
    </style>
  <link rel="stylesheet" href="/css/main.css"><script src="/js/util/domutil.js"></script><script src="/js/util/blazy.min.js"></script><script src="/js/main.js"></script>

  <script src="/js/util/three.min.js"></script><script src="/js/util/3panorama.min.js"></script>
</head>

  <body><h1>MixFlow CG</h1>
<header>
  <a href="/">
    <img class="logo" src="/images/text-logo-h.png" alt="logo image">
  </a>
  
  <nav id="main-nav-menu">
    <h1 class="hide">Site Navigator</h1>
    <ul>
      
      <li><a href="/">首页</a></li>
      
      <li><a href="/work">作品</a></li>
      
      <li><a href="/blog">博客</a></li>
      
      <li class="only-small">
        <a id="force-desktop" href="javascript:void('Force desktop resolution')">
          大屏幕版「桌面版」
        </a>
      </li>
    </ul>
  </nav>

  <div id="main-nav-switch" class="menu-icon-wrapper">
    <div class="css-icon menu"></div>
  </div>
</header>

    
      <div class="page-center">
    

<article id="post-write-racket-scheme-interpreter-on-ruby"
  class="article layout-post  "
  itemscope itemtype="https://schema.org/BlogPosting">

  <header class="article-header">
  
    <h1 class="article-title" itemprop="headline">
      使用Ruby写一个Racket(Scheme)解释器
    </h1>
  



    <div class="article-meta" >
<span class="article-author" itemprop="author">混流</span>


  <span class="publish-label">发表于</span>
  <time class="publish-time" datetime="2017-02-20T05:38:05.000Z" itemprop="datePublished">
    2017-02-20
  </time>
  <span class="modified-label">最后修改于</span>
  <time class="modified-time" datatime="2017-08-10T13:25:02.331Z" itemprop="dateModified">
    2017-08-10
  </time>


      

    </div>
  </header>

  

  
    
      
        <details class="article-table-of-contents" >
            <summary>目录</summary>
            <ol class="article-contents"><li class="article-contents-item article-contents-level-2"><a class="article-contents-link" href="#语言相关介绍"><span class="article-contents-number">1.</span> <span class="article-contents-text">语言相关介绍</span></a><ol class="article-contents-child"><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#lisp-scheme-racket-是什么"><span class="article-contents-number">1.1.</span> <span class="article-contents-text">Lisp Scheme Racket 是什么?</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#why-use-ruby"><span class="article-contents-number">1.2.</span> <span class="article-contents-text">Why use Ruby?</span></a></li></ol></li><li class="article-contents-item article-contents-level-2"><a class="article-contents-link" href="#实现一个编程语言通常的步骤"><span class="article-contents-number">2.</span> <span class="article-contents-text">实现一个编程语言通常的步骤</span></a></li><li class="article-contents-item article-contents-level-2"><a class="article-contents-link" href="#racket基本语法以及parser实现"><span class="article-contents-number">3.</span> <span class="article-contents-text">Racket基本语法以及parser实现</span></a><ol class="article-contents-child"><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#代数运算"><span class="article-contents-number">3.1.</span> <span class="article-contents-text">代数运算</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#racket所有的东西都是"><span class="article-contents-number">3.2.</span> <span class="article-contents-text">Racket所有的东西都是：</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#token"><span class="article-contents-number">3.3.</span> <span class="article-contents-text">Token</span></a></li></ol></li><li class="article-contents-item article-contents-level-2"><a class="article-contents-link" href="#abstract-syntax-tree-parse-tree"><span class="article-contents-number">4.</span> <span class="article-contents-text">Abstract Syntax Tree (Parse Tree)</span></a><ol class="article-contents-child"><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#atom"><span class="article-contents-number">4.1.</span> <span class="article-contents-text">Atom</span></a></li></ol></li><li class="article-contents-item article-contents-level-2"><a class="article-contents-link" href="#eval方法实现executorinterpreter"><span class="article-contents-number">5.</span> <span class="article-contents-text">eval方法实现executor(interpreter)</span></a><ol class="article-contents-child"><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#完成代数运算eval"><span class="article-contents-number">5.1.</span> <span class="article-contents-text">完成代数运算eval</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#function-call以及variables-in-environment"><span class="article-contents-number">5.2.</span> <span class="article-contents-text">Function call以及Variables in environment</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#工具repl-read-eval-print-loop"><span class="article-contents-number">5.3.</span> <span class="article-contents-text">工具REPL, Read-Eval-Print-Loop</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#定义变量variable"><span class="article-contents-number">5.4.</span> <span class="article-contents-text">定义变量variable</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#条件判断if语句"><span class="article-contents-number">5.5.</span> <span class="article-contents-text">条件判断、if语句</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#比较操作comparison-operators"><span class="article-contents-number">5.6.</span> <span class="article-contents-text">比较操作comparison operators</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#cons-cell-and-list"><span class="article-contents-number">5.7.</span> <span class="article-contents-text">Cons Cell and List</span></a></li><li class="article-contents-item article-contents-level-3"><a class="article-contents-link" href="#functionslambda-and-apply"><span class="article-contents-number">5.8.</span> <span class="article-contents-text">Functions，Lambda and Apply</span></a></li></ol></li><li class="article-contents-item article-contents-level-2"><a class="article-contents-link" href="#racketonruby总结"><span class="article-contents-number">6.</span> <span class="article-contents-text">RacketOnRuby总结</span></a></li></ol></details>
    
  

  <section class="article-body" itemprop="articleBody">
    <img src="/images/symbol/lambda.svg" class="center" width="200" title="lambda symbol">
<p>如果学习Lisp系语言，可能在后期都会实现一个本语言的解释器<code>interpreter</code>来练个手。</p>
<p>我学的是 Lisp(或者说Scheme) 方言之一的Racket，自己当时能写解释器的时候的确感觉不一样。<br>
毕竟之前也接触过很多语言，基本都是学的语言特性<code>feature</code>，和其流行的package使用(比如web框架)。很少接触过语言实现<code>language implemention</code>的知识。</p>
<p>当自己能写出解释器的时候，感觉到一种新的学习语言的体验。</p>
<p>这篇文章努力做到新手友好，只需要有一定编程知识基础(可能只要懂一门语言)即可阅读。</p>
<p>项目github链接：<a href="https://github.com/mixflow/RacketOnRuby/" class="uri" target="_blank" rel="external">https://github.com/mixflow/RacketOnRuby/</a> <a id="more"></a></p>
<h2 id="语言相关介绍">语言相关介绍</h2>
<p>Ruby现在还算有些名声，现在的程序员即使没用过的，可能都知道有这门语言。<br>
但是Lisp Scheme可能很多程序员都没听说过， 我当年阅读了别人推荐的《黑客与画家》 这本书才有所了解，在此之前我似乎连Lisp或者Scheme的名字都没见过。 所以有必要先简介一下。</p>
<h3 id="lisp-scheme-racket-是什么">Lisp Scheme Racket 是什么?</h3>
<p>Lisp是一门诞生于上个世纪50年代的语言。其后有很多相同思想的语言，都算得上Lisp家族的，一般被称为Lisp 方言<code>dialect</code>， 其中就包括这里提及的另外两个语言Racket Scheme。Scheme年代更加久远，影响也大些。Racket相比之下更年轻些。</p>
<p>这篇文章只涉及语言基本简单特征实现，这块哪怕语法上面Racket Scheme都没什么区别， 所以这里的Racket解释器也可看作Scheme解释器。也就是说能解释执行Scheme代码。</p>
<h3 id="why-use-ruby">Why use Ruby?</h3>
<ol style="list-style-type: decimal">
<li>当时正好也在学Ruby，所以就用Ruby实现下，纯练手。</li>
<li>这个是第二个编译器实现。最早第一个是当时学习Racket的时候，使用Racket本身实现的，编写了一个<code>metacirclar evaluator</code>，这种方式可以跳过<code>parse</code>步骤（详见紧接着的下文），因为写的代码就已经是AST了（依旧详见下文）。那么用Ruby来实现Racket的话，是需要<code>parser</code>，所以也能再多练一些(虽说parser也没什么复杂的)。</li>
<li>《黑客与画家》中 <em>“如果回到1975年，你声称它(Ruby)是一种有着自己语法的Lisp方言，没有人会提出反对意见。”</em>。<br>
作者认为Ruby也可以视为Lisp的一种方言。那么我反过来通过Lisp的方言来实现Lisp，想法有些古怪，但我认为有点意思。</li>
</ol>
<h2 id="实现一个编程语言通常的步骤">实现一个编程语言通常的步骤</h2>
<p>下面涉及的是一个典型的语言实现<code>language implemention</code>的流程：</p>
<ol style="list-style-type: decimal">
<li>首先接受一串字符串<code>string</code>，其内容就是用此语言编写的程序。如果该字符串不是符合语法结构<em>syntactically well-formed</em>（比如关键字拼写错误等），分析器<code>parser</code>会报错。</li>
<li>如果没有上述的语法错误，parser会生成一个树<code>tree</code>来表示程序。这个树一般称为<code>abstract-syntax tree</code>，简称为<code>AST</code>。
<ul>
<li>如果语言有<code>类型检查 type-checking</code>或其他原因，认定AST仍然不是一个合法的程序。 <code>类型检查器 type-checker</code>就会生成错误信息。</li>
<li>如果没有上述错误, AST就会被传递给后续流程。</li>
</ul></li>
<li>实现目标编程语言<code>language B</code>的剩余流程，基本就是如下两种方案。
<ul>
<li>可以用另一门语言<code>language A</code>编写<code>解释器 interpreter</code>来接受使用<code>language B</code>编写的程序，并最终产生结果。这里用来实现interpreter的language A，有个专门术语称呼：<code>metalanguage</code>。</li>
</ul>
<blockquote>
<p>如果把这个<code>language A</code>程序称作<code>evaluator for B</code>（evaluate中文对应术语一般叫求值，大概意思达到了，但我个人觉得不太准确）或者<code>执行器 executor for B</code>，可能会更直白些。但<code>解释器 interpreter</code>是约定俗成的术语。</p>
</blockquote>
<ul>
<li>另外一种方式再<code>language A</code>写一个<code>编译器 compiler</code>来将<code>language B</code>写的程序生成一个等价<em>equivalent</em> <code>language C</code>的程序。 然后再使用早已存在的<code>language C</code>语言实现。</li>
</ul>
<blockquote>
<p><code>编译器 compiler</code>可能称为<code>翻译器 translator</code>更好，与interpreter同样的原因，compiler是个普遍使用的术语。</p>
</blockquote></li>
</ol>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/d/d6/Parser_Flow%D5%B8.gif" alt="implementing program language workflow from wikipedia parsing">
<p class="caption">implementing program language workflow from <a href="https://en.wikipedia.org/wiki/Parsing" target="_blank" rel="external">wikipedia parsing</a></p>
</div>
<p>另外要说教下，编译器以及解释器只是<strong>编程语言实现方式的特征<em>the feature of a particular programming language implementation</em></strong>，而不是编程语言自身的特征<em>the feature of the programming language</em>。所以“编译性语言” <em>compile language</em> 或者“解释性语言” <em>interpreter language</em> 的说法<strong>完全没有意义</strong>。完全可以给Lisp,Scheme系语言编写一个compiler(这些语言的解释器实现比较常见)，给C语言编写一个解释器也是完全可行的。</p>
<h2 id="racket基本语法以及parser实现">Racket基本语法以及parser实现</h2>
<p>建议先在<a href="http://download.racket-lang.org/" target="_blank" rel="external">Racket官网下载</a>原生Racket以及配套IDE DrRacket，写Racket或者Scheme程序方便些。 另外本文interpreter实现基本不包含检测和错误处理，所以测试代码最好先在原生Racket里面执行下。</p>
<p>需要快速了解Racket基本语法，推荐此篇快速介绍文章<a href="https://learnxinyminutes.com/docs/racket/" target="_blank" rel="external">Learn X in Y minutes, When x = Racket</a>。</p>
<h3 id="代数运算">代数运算</h3>
<figure class="highlight scheme"><figcaption><span>Racket</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">3</span>))</div></pre></td></tr></table></figure>
<p>先来个简单的Racket代码例子，上述代码较内层括号<code>(* 2 3)</code>是乘法运算，然后在外层括号内再将上述乘法运算结果加上2。 整个代码等价于数学或者常见编程语言<code>2 + 2 * 3</code>代码意义。</p>
<p>一开始就比较不同寻常，对于此类Racket代码可以看作<code>操作符 operator</code>以及<code>操作数 operand</code>的组合，再用括号包裹。比如<code>(+ 1 1)</code>就可以把<code>+</code>看作操作符。另外可以括号形式的代码嵌套，比如上述先乘后加的代数运算。</p>
<p>这种代码形式，实际非常简单，我们可以给一个更加明确的定义如下节。</p>
<h3 id="racket所有的东西都是">Racket所有的东西都是：</h3>
<p>就两种！</p>
<ol style="list-style-type: decimal">
<li>一个<code>atom</code>，比如数字<code>3</code>、字符串<code>&quot;hello&quot;</code>、<code>#t</code>、<code>#f</code>、<code>null</code>。也包括一种atom的：<code>识别符 identifier</code>,可以是<code>变量variable</code>,<br>
或者是<code>特别形式special form</code>诸如<code>define</code>、<code>lambda</code>、<code>if</code>。(涉及的名词或者术语，不理解没关系，再后文会一一介绍)</li>
<li>或者是在括号的一序列<em>sequence</em>东西<code>(t1 t2 t3 ... tn)</code>。</li>
</ol>
<p>该定义还有个专门的名称<a href="https://en.wikipedia.org/wiki/S-expression" target="_blank" rel="external">S-expression</a>，随着Lisp诞生给出的定义用来描述Lisp。</p>
<p>详说下第二种情况。括号里的第一东西t1，影响余下的序列中的东西。 如果是<code>special form</code>，比如<code>define</code>，以为定义一个东西，要么是变量<em>variable</em>，要么是函数<em>function</em>（<code>lambda</code>）。</p>
<p>如果不是<code>special form</code>，剩余情况一般是函数执行<em>function call</em>，很多东西在Racket里都是函数，比如加减<code>+</code>和<code>-</code>。</p>
<p>在Racket里括号是很常见的，而且括号作用非常明确。不会遇到<code>f x y</code>是<code>(f x) y</code>还是<code>f (x y)</code>的疑惑。 Racket的括号直接影响着<code>解析parsing</code>，将代码转换成树形结构。实际上Racket代码本身就是树形结构。</p>
<p>如果没有了解过Lisp系语言，大部分人看到一段比较长的代码，都会觉得充满了括号的怪异语法。如果能抛开这些成见，学习使用后实际上能很快适应。</p>
<h3 id="token">Token</h3>
<p>具体到parser中第一步<code>生成token token generator</code>或者叫<code>词汇分析lexical Analysis</code>。可以参照上文实现语言通常流程小节引用的流程图，其中’parser’部分。</p>
<p>这个过程就是把代码字符串分割成多个有意义的符号。这个过程一般使用正则表达式<em>regural expression</em>简称<em>regex</em>。这些符号专门的术语就是<code>token</code>。</p>
<figure class="highlight ruby"><figcaption><span>write token generator on ruby</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Racket</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(str)</span></span></div><div class="line">        str.gsub(<span class="string">"("</span>, <span class="string">"( "</span>) <span class="comment"># add space after '('</span></div><div class="line">           .gsub(<span class="string">")"</span>, <span class="string">" )"</span>) <span class="comment"># add space before ')'</span></div><div class="line">           .split(<span class="string">" "</span>) <span class="comment"># split string into an array(tokens) base on whitespaces</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>快速简介下ruby，本文在前言里面提及了面向新手，所以会对于不了解ruby的读者涉及一些介绍，<strong>这部分内容我会用引言块注明（如下），如果不需要，随意跳过。</strong> 不光会有ruby知识，还有一些别的编程知识。</p>
<blockquote>
<p>Ruby是一种<code>动态类型dynamic type</code> <code>面向对象object oriented</code>编程语言。我定义了一个名叫Racket的<code>类class</code>。 其中定义了一个名叫tokenize的函数。函数有一个’str’的参数，用来接收代码字符串。注意class和method都使用了end明确表明各自代码块的结束部分，ruby里面大部分代码快都需要end结尾，比如if。<br>
另外ruby函数会自动返回最后一个对象。当然你也可以明确<em>explicitly</em>使用<code>return</code>，比如条件（if）分支需要返回的情形。</p>
</blockquote>
<p>代码很简单，先将这对括号“()”内测增加一个空格，方便最后<code>分割split</code>操作。<code>gsub</code>便是替换操作。</p>
<blockquote>
<p><code>str.gsub(...).gsub(...).split(...)</code>这种连着执行函数模式，术语叫做<em>chaining</em>。自己写的代码函数返回对象即可做到。<br>
另外这种风格并不是ruby或者别的某个语言特有的，是一种<code>习惯用法idiom</code>。好处就是少些变量名或者赋值，另外也没必要构造一个大而全方法，完全可以构建更合理多个方法并连续调用从而达到目标。</p>
</blockquote>
<p>下面便测试下上述代码 使用系统的命令行工具到相应的代码目录。确保安装ruby后输入<code>irb</code>命令，定义一段代码string，传入<code>tokenize</code>函数生成token。 <figure class="highlight irb"><figcaption><span>Test Tokenize</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">c:</span>\Projects\RacketOnRuby&gt;irb</div><div class="line"><span class="meta">irb(main):001:0&gt;</span> load <span class="string">'racket.rb'</span></div><div class="line">=&gt; true</div><div class="line"><span class="meta">irb(main):002:0&gt;</span> r = Racket.new</div><div class="line">=&gt; #&lt;Racket:0x00000002e67df8&gt;</div><div class="line"><span class="meta">irb(main):003:0&gt;</span> str = <span class="string">%&#123;(+ 1</span></div><div class="line">irb(main):004:0"      (* 2</div><div class="line">irb(main):005:0"         (- 7 3)))</div><div class="line">irb(main):006:0" &#125;</div><div class="line">=&gt; <span class="string">"(+ 1\n     (* 2\n        (- 7 3)))\n"</span></div><div class="line"><span class="meta">irb(main):007:0&gt;</span> p r.tokenize(str)</div><div class="line">[<span class="string">"("</span>, <span class="string">"+"</span>, <span class="string">"1"</span>, <span class="string">"("</span>, <span class="string">"*"</span>, <span class="string">"2"</span>, <span class="string">"("</span>, <span class="string">"-"</span>, <span class="string">"7"</span>, <span class="string">"3"</span>, <span class="string">")"</span>, <span class="string">")"</span>, <span class="string">")"</span>]</div><div class="line">=&gt; [<span class="string">"("</span>, <span class="string">"+"</span>, <span class="string">"1"</span>, <span class="string">"("</span>, <span class="string">"*"</span>, <span class="string">"2"</span>, <span class="string">"("</span>, <span class="string">"-"</span>, <span class="string">"7"</span>, <span class="string">"3"</span>, <span class="string">")"</span>, <span class="string">")"</span>, <span class="string">")"</span>]</div></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>第1行（最左边的行号）<code>irb</code>进入ruby REPL。没听过REPL，先粗略认为REPL就是专门执行代码的命令工具。下文<a href="#工具repl-read-eval-print-loop">REPL章节</a>会详细的涉及，因为我们实现Racket也要写个Racket的REPL，来方便测试。</li>
<li>第2行加载包含Racket class的相应的ruby file。 我的ruby文件名就叫做racket.rb。</li>
<li>第4行创建一个Racket的对象<code>实例instance</code>。该实例将来调用相应的函数进行<code>tokenize</code>以及后续的操作。Ruby的语法syntax，很多时候执行函数都可以省略括号，比如此处创建对象的时候调用<code>new</code>构造函数，可选写法：<code>Racket.new()</code>两种代码等价的。</li>
<li>6行到9行，定义了变量名为<code>str</code>的code string。 <code>%{...}</code>是ruby定义多行字符串的一种语法syntax。</li>
<li>第10行，irb会自动输出之前代码执行结果返回的对象（包括之前的3、5行）。其中把换行转义成了’’输出在一行。</li>
<li>第11行，调用<code>tokenize</code>函数，并传入上一步定义的string。并打印输出结果即tokens</li>
</ul>
</blockquote>
<blockquote>
<p>可以把上述命令行中的ruby测试代码放入专门的rb文件，这样就无需在每次重新测试再敲代码。例如github项目中的<em>example.rb</em>，直接系统命令行执行<code>ruby example.rb</code></p>
</blockquote>
<p>此前代码，在<code>tokenize</code>函数多了第一步处理是把多个空白符转化成单个隔空&quot; “，然而写这篇文章的时候，我重新审查了下代码，并不需要多此一举。多余的代码：<code>str.gsub(/\s{2,}/, &quot; &quot;)</code></p>
<p>原因是<code>split</code>方法传入单个空格字符串的时候，会基于空白符<em>whitespace</em>分割，而且会忽略余下的紧挨着的空白符。<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>token生成好了，下面便是分析token并生成AST了。</p>
<h2 id="abstract-syntax-tree-parse-tree">Abstract Syntax Tree (Parse Tree)</h2>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_ast</span><span class="params">(tokens)</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">aux</span><span class="params">(tokens, acc)</span></span></div><div class="line">        <span class="keyword">if</span> tokens.empty?</div><div class="line">            <span class="comment"># no tokens left, return result</span></div><div class="line">            <span class="keyword">return</span> acc</div><div class="line">        <span class="keyword">end</span></div><div class="line"></div><div class="line">        token = tokens.shift <span class="comment"># get first token</span></div><div class="line">        <span class="keyword">if</span> <span class="string">'('</span> == token <span class="comment"># start one s-expression</span></div><div class="line">            sub_ast = aux tokens, []</div><div class="line">            acc.push sub_ast</div><div class="line"></div><div class="line">            aux(tokens,  acc) <span class="comment"># recursive call to continue handling rest tokens</span></div><div class="line">        <span class="keyword">elsif</span> <span class="string">')'</span> == token <span class="comment"># end one s-expression</span></div><div class="line">            <span class="keyword">return</span> acc</div><div class="line">        <span class="keyword">else</span></div><div class="line">            acc.push atom(token) <span class="comment"># convent current token to atom</span></div><div class="line">            aux tokens, acc <span class="comment"># recursive</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    aux tokens, [] <span class="comment"># initial call helper</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>真正起作用的是<code>generate_ast</code>内部定义<code>aux</code>（<em>auxiliary辅助</em>, <em>helper</em>）的方法，处理tokens，其参数<code>acc</code>（<em>accumulator累加器</em>）存放的处理得到的AST。</p>
<p>主要使用<code>递归 recursion</code>从左到右处理<code>tokens</code>里面的每一个token：</p>
<ul>
<li>tokens为空的时候，返回<code>acc</code>即AST结果。</li>
<li>当遇到左括号时，说明遇到一个s-expression的序列，递归调用<code>aux</code>方法的时候给<code>acc</code>参数传入一个新的空array（上述第10行代码），用来存储这部分subdivision s-expression序列对应的AST结果。<br>
第11行，递归调用处理完返回<code>subdivision acc</code>结果，追加到原来acc后面。</li>
<li>当遇到右括号的时候，说明s-expression的结束，返回结果<code>acc</code>，对应上一点的<code>subdivsion acc</code>。<br>
</li>
<li>剩余其他情况，将token转化为atom，紧接的下文涉及atom实现细节。</li>
</ul>
<p>实际<code>generate_ast</code>方法简化下就是匹配括号的代码，包括嵌套<em>nested</em>结构。</p>
<blockquote>
<p>上述代码并没有检测括号是否匹配，因为需要文章简洁，这里只贴出不检测括号的代码，github上面的源文件里面包含有完整的括号检测。<br>
racket里面除了可以使用圆括号()，也可以使用方括号[]，两者功能作用没有区别，编码习惯在某些地方会使用[]，但不遵循也不会有什么实质影响。唯一注意的就是要对应的括号匹配，不能混用，比如<code>(+ 1 1]</code>就是语法不正确。</p>
</blockquote>
<h3 id="atom">Atom</h3>
<figure class="highlight ruby"><figcaption><span>s-expression atom</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">atom</span><span class="params">(token)</span></span></div><div class="line">    str_part = token[<span class="regexp">/^"(.*)"$/</span>, <span class="number">1</span>] <span class="comment"># try match string(start and end with ")</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> str_part.<span class="literal">nil</span>?</div><div class="line">        str_part</div><div class="line">    <span class="keyword">elsif</span> token[<span class="regexp">/(?=(\.|[eE]))(\.\d+)?([eE][+-]?\d+)?$/</span>]  <span class="comment"># decimal</span></div><div class="line">        token.to_f</div><div class="line">    <span class="keyword">elsif</span> token[<span class="regexp">/^\d+$/</span>] <span class="comment"># integer</span></div><div class="line">        token.to_i</div><div class="line">    <span class="keyword">else</span> <span class="comment"># symbol</span></div><div class="line">        token.to_sym</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>刚才上文我们已经处理了s-expression序列，即<a href="#racket所有的东西都是">上文提及s-expression</a>第二种情形。此处<code>atom</code>为第一种情况，具体又有细分，可能是string、数字、也有可能是<code>identifier</code>。对应代码中<code>if</code>语句各个分支，通过正则式尝试匹配<code>token</code>（Ruby string对象）：</p>
<ol style="list-style-type: decimal">
<li>在Racket中头尾各一个双引号<code>&quot;</code>来包含字符串。第一个if便是通过正则式匹配首尾“，如果的确是string，其中间部分取出就是对应的Ruby string类型的对象。</li>
<li><p>第二个if分支判断是否为浮点数。这里的正则式看起来很复杂，简单代替方案是仅仅匹配小数点（正则式为 <code>/\.\d+$/</code>）。这里复杂的正则式是除了用来匹配小数外，还能匹配指数<em>exponential</em>，Ruby中指数类似1e5也算作浮点数(等同于10000.0，Racket中也是同样的)。to_f便是将string转化为float浮点数的方法。这里举出4个数<code>.003</code> <code>0.5</code> <code>32e3</code> <code>.24e5</code>，这些都是浮点数，我们的正则式便是能够匹配出对应小数点部分以及指数部分，测试代码如下，第一行这四个数尝试使用该正则式匹配，第二行是匹配部分的结果: <figure class="highlight ruby"><figcaption><span>decimal and exponential</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'.003'</span>, <span class="string">'0.5'</span>, <span class="string">'32e3'</span>, <span class="string">'.24e5'</span>].map&#123;<span class="params">|num|</span> num[<span class="regexp">/(?=(\.|[eE]))(\.\d+)?([eE][+-]?\d+)?$/</span>] &#125;</div><div class="line"><span class="comment"># =&gt; [".003", ".5", "e3", ".24e5"]</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>Ruby Array的map方法，是将其中每个元素都进行block中处理。 <code>{ |num| ...}</code>形式就是block，此处Array.map会往block的num参数 传入单个元素。</p>
</blockquote></li>
<li>第三个if分支，尝试匹配是否为整数。to_i便把string是转化整数<em>integer</em>的方法</li>
<li><p>最后一个else分支，剩下情况可能是变量名或者special form比如<code>lambda</code> <code>define</code>等。最后转化为Ruby <code>符号Symbol</code>类型。所谓symbol类似string，symbol为不可变<code>immutable</code>，而且其值一样的话，就是同一个对象。</p>
<blockquote>
<p>Ruby中symbol是以<code>:</code>作为开头，例如<code>:hello</code>。两两比对的时候symbol效率更高。不像string一个一个字符<em>char</em>进行比对，symbol直接比对两者在内存中是否为同一个对象。</p>
</blockquote></li>
</ol>
<p>到此为止，实现了生成AST的部分，下面就要涉及interpreter部分了。</p>
<h2 id="eval方法实现executorinterpreter">eval方法实现executor(interpreter)</h2>
<p>有些表达式<em>expression</em>中会包含变量<em>variable</em>，求值<em>evaluate</em>这些表达式就需要<code>environment</code>，通过variable获得对应值<em>vaLue</em>。</p>
<p>environment的实现是<code>metalanguage</code>的一部分，metalanguage这里就是我们使用的Ruby。这里使用hash数据结构来代表environment。</p>
<h3 id="完成代数运算eval">完成代数运算eval</h3>
<p>文章一开始的提及的代数运算的Racket代码<code>(+ 1 (* 2 3))</code>，首先将其实现: <figure class="highlight ruby"><figcaption><span>eval algebra operators</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">()</span></span></div><div class="line">    @env = &#123;</div><div class="line">        <span class="symbol">:+</span> =&gt; lambda&#123;<span class="params">|x, y|</span> x+y&#125;,</div><div class="line">        <span class="symbol">:*</span> =&gt; lambda&#123;<span class="params">|x, y|</span> x*y&#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(exp, env=@env)</span></span></div><div class="line">    <span class="keyword">if</span> exp.is_a? Numeric</div><div class="line">        exp <span class="comment"># is a number(integer and float) return itself</span></div><div class="line">    <span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:+</span> <span class="keyword">or</span> exp[<span class="number">0</span>] == <span class="symbol">:*</span></div><div class="line">        env[ exp[<span class="number">0</span>] ].call( eval(exp[<span class="number">1</span>], env), eval(exp[<span class="number">2</span>], env) )</div><div class="line">    <span class="keyword">else</span></div><div class="line">        results = exp.map &#123; <span class="params">|subexp|</span> eval(subexp, env) &#125;</div><div class="line">        results[-<span class="number">1</span>]</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>增加了两个方法<code>initialize</code>以及<code>eval</code>。</p>
<blockquote>
<p><code>initialize</code>方法是Ruby的对象的构造器方法，即<code>new</code>对象时候会调用该方法，该方法可以省略，我们之前<code>parser</code>部分就不需要构造方法，所以就一直没有<code>initialize</code>。</p>
</blockquote>
<blockquote>
<p>Ruby中<code>@</code>开头的变量是<code>实例变量instance variable</code>，作用范围为单个对象实例内，所有该对象的内部方法都可以访问到。<br>
另外<code>@@</code>两个at符号开头是<code>类变量class variable</code>，顾名思义即同一个类创建的所有对象实例 都共享同一个类变量。<br>
Ruby<strong>不需要提前声明variable</strong>，赋值一个之前不存在的variable，会自动创建该variable。</p>
</blockquote>
<p>其中<code>initialize</code>方法中，定义了一个<code>@env</code>实例变量，并赋值了一个hash。之前说过，在Racket中代数运算看作函数，metalanguage(Ruby)实现了<code>+</code>和<code>*</code>各自对应的lambda（或者叫Proc object，ruby的术语），lambda可以看作匿名函数，该匿名函数接受两个参数<code>x``y</code>，将其相加或者相乘。</p>
<p>后文还会详细介绍lambda，因为我们也要实现Racket的lambda，Racket和Ruby的lambda基本是同一个东西，仅语法有区别。</p>
<p>eval方法依旧含有recursive call，递归很适合处理嵌套形式，处理 子表达式<em>subexpression</em>，需要返回的情形结果可能有差异。</p>
<ul>
<li>第一个if条件分支，判断如果表达式只是纯粹数字，那么不需要额外处理，返回自身。</li>
<li>第二个条件分支，涉及expression的首个thing如果是<code>:+</code>或者<code>:*</code>，<code>env[ exp[0] ]</code>则去environment中查找对应的函数。调用传入expression紧接着的2个thing，作为两个操作数。注意此处都会先执行下eval方法，因为可能是需要处理的subexpression，同时也是使用的同样的environment。</li>
<li>最后一个条件分支，之前实现的parser实际上可以处理多个expression，例如<code>(+ 1 1) (* 2 2) (+ 3 4)</code>这样的代码中包含三个expression，parser处理完后的AST为<code>[[:+, 1, 1], [:*, 2, 2], [:+, 3, 4]]</code>，包含三个expression处理后的AST的array。即使只有一个expression，parser处理后也是一个长度为1的array，例如该章开始提到的代码，parse后的结果：<code>[ [:+ 1 [:* 2 3]] ]</code>。<br>
这里，我返回的最后一个结果。当然也可以直接放回<code>results</code>结果array。自己写的interpreter，细节由自己定义。</li>
</ul>
<h3 id="function-call以及variables-in-environment">Function call以及Variables in environment</h3>
<p>上面处理加和乘，可以改写成处理任何方法的通用办法. <figure class="highlight ruby"><figcaption><span>updated call functions</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_expressions</span><span class="params">(exps, env=@env)</span></span></div><div class="line">    results = exps.map &#123; <span class="params">|one_exp|</span> eval(one_exp, env) &#125;</div><div class="line">    results[-<span class="number">1</span>]</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(exp, env=@env)</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lookup_env</span><span class="params">(env, var)</span></span></div><div class="line">        error_no_var = <span class="string">"undefined: \"%s\""</span> % var</div><div class="line">        val = env[var]</div><div class="line"></div><div class="line">        <span class="keyword">if</span> val.<span class="literal">nil</span>?</div><div class="line">            raise error_no_var</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> exp.is_a? Numeric</div><div class="line">        exp <span class="comment"># is a number(integer and float) return itself</span></div><div class="line">    <span class="keyword">elsif</span> exp.is_a? Symbol</div><div class="line">        lookup_env(env, exp)</div><div class="line">    <span class="keyword">else</span></div><div class="line">        operator = eval(exp[<span class="number">0</span>], env) <span class="comment"># first thing of s-expression sequence.</span></div><div class="line">        operands = exp[<span class="number">1</span>..-<span class="number">1</span>].map &#123;<span class="params">|sub_exp|</span> eval(sub_exp, env) &#125; <span class="comment"># the rest things of sequence</span></div><div class="line">        operator.call *operands</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>将处理多个expression的办法提炼成<code>eval_expressions</code>方法。这样的话parse处理完后的AST(结果都是array，一个或多个expression)就先调用<code>eval_expressions</code>处理。而<code>eval</code>只用来处理单个expression。这样处理的理由，如果包含在<code>eval</code>一个条件分支的话，会与单个expression处理混乱（因为同样使用array来存放s-expression）。</p>
<p><code>else</code>分支就是处理方法调用，expression第一个thing也执行了<code>eval</code>。这样就可以处理这样的<code>( (if #t + *) 2 3 )</code>Racket代码（第一个thing也可能是sub expresion）。</p>
<blockquote>
<p><code>operator.call *operands</code>中<code>oprands</code>是array，其前面<code>*</code>是<code>splat operator</code>。作用是将数组拆开，每个元素对应到单个参数。反过来，在函数参数声明时候也可以使用<code>*</code>，作用也是相反的，将传入的单个参数值组成array。</p>
</blockquote>
<p>另外，多了处理symbol atom的步骤，一般symbol为variable的时候，就需要到environment查找对应的value，即<code>lookup_env</code>方法。该方法很简单，就是通过variable作为key查找environment对应的值，没有variable的话就抛出一个简单错误提示该variable没被定义。</p>
<p>如果完整代数运算，除法和减法<code>:/</code>，<code>:-</code>可以类似上面写法。但是重复劳动了，用程序来做重复的事。另外还有一点需要改进，Racket中代数运算符，可以接受多个数字，进行累积运算。<br>
例如<code>(+ 1 4 5 7)</code>执行结果为<code>17</code>，<code>(* 2 3 4)</code>执行结果为<code>24</code>。 <figure class="highlight ruby"><figcaption><span>updated algebra</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ALGEBRA_OPERATORS = [<span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:*</span>, <span class="symbol">:/</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">()</span></span></div><div class="line">    @env = &#123;</div><div class="line">    &#125;</div><div class="line">    ALGEBRA_OPERATORS.map <span class="keyword">do</span> <span class="params">|opt|</span></div><div class="line">        @env[opt] = lambda&#123; <span class="params">|*operands|</span> operands.inject(opt) &#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>改写成上述代码，通过程序往environment增加每个代数运算符对应的lambda函数。看到这似乎炫技嫌疑，但实际后面也有相同的思想的实现，比较大小的comparison operator也是类似的（也是能接受多个参数）</p>
<p>至此<code>eval</code>的大致结构功能如此。后文涉及的新的Racket feature，就是往<code>eval</code>增加更多情况的处理，方式可能是增加条件分支，也有可能是往environment中增加函数（可以看作Racket自带的函数）。</p>
<h3 id="工具repl-read-eval-print-loop">工具REPL, Read-Eval-Print-Loop</h3>
<p>在继续完备eval方法之前，首先实现REPL这个工具，让调试Racket代码更加方便。就如之前执行Ruby代码的<code>irb</code>。 REPL全称read-eval-print-loop顾名思义，其过程: 读取code -&gt; eval求值这段代码 -&gt; 输出结果 -&gt; 循环上述步骤。 <figure class="highlight ruby"><figcaption><span>REPL</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">(prompt=<span class="string">'RacketOnRb &gt;&gt;'</span>, output_prompt=<span class="string">"=&gt;"</span>)</span></span></div><div class="line">    <span class="keyword">while</span> <span class="literal">true</span></div><div class="line">        print prompt</div><div class="line">        code = gets</div><div class="line"></div><div class="line">        <span class="keyword">begin</span></div><div class="line">            ast = parse(code)</div><div class="line">            result = eval_expressions(ast)</div><div class="line">            puts output_prompt + result.to_s</div><div class="line">        <span class="keyword">rescue</span> Exception =&gt; e</div><div class="line">            puts e</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>相当直接的代码，一个无限循环，接受console输入Racket代码，然后解析执行代码，即之前描述的过程。<br>
执行<code>parse</code>，<code>eval</code>这部分时，会尝试捕获异常，如果有异常只是打印出来，继续loop。这样就能避免出错整个program终止，需要重新执行该repl方法。</p>
<h3 id="定义变量variable">定义变量variable</h3>
<p>前面已经完成查询variable对应的value的方法。相应我们需要实现定义变量，其语法<code>(define &lt;var&gt; &lt;exp&gt;)</code>。 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:define</span></div><div class="line">    <span class="number">_</span>, var, value_exp = exp</div><div class="line">    env[var] = eval( value_exp, env )</div></pre></td></tr></table></figure></p>
<p>放置于处理function call分支之前即可。</p>
<h3 id="条件判断if语句">条件判断、if语句</h3>
<p>Racket中用<code>#t</code>和<code>#f</code>表示true和false。</p>
<p>Racket if的语法：<code>(if &lt;test-exp&gt; &lt;then-exp&gt; &lt;else-exp&gt;)</code>当<test-exp>执行结果不是<code>#f</code>的时候，执行<code>&lt;then-exp&gt;</code>分支，否则执行<code>&lt;else-exp&gt;</code>分支 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@env = &#123;</div><div class="line">    <span class="symbol">:<span class="string">'#t'</span></span> =&gt; <span class="literal">true</span>,</div><div class="line">    <span class="symbol">:<span class="string">'#f'</span></span> =&gt; <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="comment"># ...</span></div><div class="line"><span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:if</span></div><div class="line">    <span class="number">_</span>, test_exp, then_exp, else_exp = exp</div><div class="line">    <span class="keyword">if</span> eval(test_exp, env) == <span class="literal">false</span></div><div class="line">        eval( else_exp, env )</div><div class="line">    <span class="keyword">else</span> <span class="comment"># other than false(#f)</span></div><div class="line">        eval( then_exp, env)</div><div class="line">    <span class="keyword">end</span></div></pre></td></tr></table></figure></test-exp></p>
<p>ruby注释使用<code>#</code>，如果symbol含有#的话，需要用引号括起来。这里会把Racket的<code>#t #f</code>转化为Ruby中的true和false。</p>
<h3 id="比较操作comparison-operators">比较操作comparison operators</h3>
<p>至于比较操作，上文提过了类似代数操作实现。 当有多个需要比较的对象时，比较操作需要两两比较，所有两两比较结果为true，则返回true，否则false。 <code>each_cons(n)</code>就是(Ruby提供方法来遍历连续<em>consecutive</em>的n个元素)。<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <figure class="highlight ruby"><figcaption><span>comparision</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">COMPARISION = [<span class="symbol">:==</span>, <span class="symbol">:</span>!=, <span class="symbol">:&lt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:&gt;=</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">()</span></span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">    COMPARISION.map <span class="keyword">do</span> <span class="params">|opt|</span></div><div class="line">        @env[opt] = lambda&#123; <span class="params">|*args|</span> args.each_cons(<span class="number">2</span>).all? &#123;<span class="params">|x, y|</span> x.method(opt).call(y)&#125; &#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>Ruby和其他大部分语言，使用<code>=</code>代表赋值操作，所以比较是否相等时候使用<code>==</code>。但是Racket有专门的<code>define</code>操作，所以依旧使用<code>=</code>代表比较是否相等的函数。<br>
我追求简单，所以实现套用Ruby语法。如果要改为Scheme Racket语法也很简单，多做一次符号映射即可，其他不做赘述了。</p>
<h3 id="cons-cell-and-list">Cons Cell and List</h3>
<p><code>cons</code>操作用来构建一个pair，其通过<code>car</code>获得pair的第一个数据，通过<code>cdr</code>获得pair的第二个数据，pair有专门的术语：<code>cons cell</code>。</p>
<p>另外Racket有个特许且常用的<code>cons cell</code>形式：<code>list</code>，例如<code>(cons 1 (cons 2 (cons 3 (cons 4 null))))</code>代码，nested cons cells，最后一个（最内部的pair）的第二数据以<code>null</code>为结尾。<br>
<code>null</code>在Racket中代表空list，<code>null?</code>判断是否为空的函数。list有个更加简便的写法<code>(list 1 2 3 4)</code>等同上行的代码例子。</p>
<table>
<colgroup>
<col width="17%">
<col width="40%">
<col width="41%">
</colgroup>
<thead>
<tr class="header">
<th align="left">Primitive</th>
<th align="left">Description</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">null</td>
<td align="left">The empty list</td>
<td align="left">null</td>
</tr>
<tr class="even">
<td align="left">cons</td>
<td align="left">Construct a list</td>
<td align="left">(cons 2 (cons 3 null))</td>
</tr>
<tr class="odd">
<td align="left">car</td>
<td align="left">Get rst element of a list</td>
<td align="left">(car some-list)</td>
</tr>
<tr class="even">
<td align="left">cdr</td>
<td align="left">Get tail of a list</td>
<td align="left">(cdr some-list)</td>
</tr>
<tr class="odd">
<td align="left">null?</td>
<td align="left">Return #t for the empty-list and #f otherwise</td>
<td align="left">(null? some-value)</td>
</tr>
</tbody>
</table>
<p>对于Ruby实现代码，我们使用array来存放<code>cons cells</code>，固定两个元素。</p>
<p>对于<code>list</code>函数实现，依旧采用recursion方式，cons（直接构造Ruby array）第一个参数以及余下参数构成的list，很直白实现方式。</p>
<figure class="highlight ruby"><figcaption><span>cons cells</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">:null?</span> =&gt; lambda &#123; <span class="params">|exp|</span> <span class="symbol">:null</span> == exp &#125;, <span class="comment"># racket empty list.</span></div><div class="line"><span class="symbol">:cons</span> =&gt; lambda &#123; <span class="params">|x, cell|</span> [x, cell] &#125;,</div><div class="line"><span class="symbol">:car</span> =&gt; lambda &#123; <span class="params">|cell|</span> cell[<span class="number">0</span>]&#125;,</div><div class="line"><span class="symbol">:cdr</span> =&gt; lambda &#123; <span class="params">|cell|</span> cell[<span class="number">1</span>] &#125;,</div><div class="line"><span class="symbol">:list</span> =&gt; lambda <span class="keyword">do</span> <span class="params">|*args|</span></div><div class="line">    <span class="comment"># racket code '(list 1 2 3)' is equivalent to '(cons 1 (cons 2 (cons 3 null)))'</span></div><div class="line">    racket_list_helper= lambda <span class="keyword">do</span> <span class="params">|args|</span></div><div class="line">        <span class="keyword">if</span> args.empty? <span class="keyword">then</span> <span class="symbol">:null</span></div><div class="line">        <span class="keyword">else</span> [args[<span class="number">0</span>], racket_list_helper.call(args[<span class="number">1</span>..-<span class="number">1</span>])]</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    racket_list_helper.call(args)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<!-- TODO: map, filter, fold -->
<h3 id="functionslambda-and-apply">Functions，Lambda and Apply</h3>
<blockquote class="pullquote has-quotes"> <!-- TODO: pullquote style -->
问题弄清楚后，答案自然就清楚了。</blockquote>
<p>到了我觉得最重要的function部分了。目标实现function，只需要搞清楚何为function就知道如何实现，首先先要明确一些相关的概念。</p>
<p>Racket的函数遵循<code>lexical scope</code>又称作<code>static scope</code>，函数的正文部分求值时，所用的environment在该函数被定义时候的enviroment。相对立的<code>dynamic scope</code>，就是函数求值时，使用的函数被调用的enviroment。</p>
<blockquote>
<p>The body of function is evaluated in the environment when the function is <strong>defined</strong>, not the environment when the function is <strong>called</strong>.</p>
</blockquote>
<p>现在主流编程语言基本都是使用<code>lexical scope</code>，程序行为更可控。</p>
<p>除了定义的时候的environment，方法执行的时候，还会将该environment扩展添加参数<em>parameters</em>以及其对应传入的值<em>arguments</em>。</p>
<p>function(或者叫lambda, procedure)的实现代码如下，存放lambda的parameters和body，以及定义时候的envrioment，就如同上文描述那样。</p>
<p>定义了Closure class，只是用来存放closure的值。也可以用数组<code>[:closure, parameters, body, env]</code>存放，通过index取值，但是这样的话<code>:closure</code>可以被覆盖。</p>
<p>真正执行部分，处于之前执行方法部分，之前处理例如加法之类的primitive procedures。现在增加分支专门处理，用户定义的函数<em>compound procedures</em>。 操作数部分与之前一样，先eval，然后补充进函数定义时的environment。该environment为执行函数体<em>body</em>的环境，然后求值。</p>
<figure class="highlight ruby"><figcaption><span>closure</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Closure</span></span></div><div class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:parameters</span>, <span class="symbol">:body</span>, <span class="symbol">:env</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(parameters, body ,env)</span></span></div><div class="line">        @parameters = parameters</div><div class="line">        @body = body</div><div class="line">        @env = env</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(exp, env)</span></span></div><div class="line">    <span class="comment"># ... other part code</span></div><div class="line">    <span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:lambda</span></div><div class="line">        <span class="number">_</span>, parameter_names, fun_body = exp</div><div class="line">        Closure.new(parameter_names, fun_body, env)</div><div class="line">    <span class="comment"># ... other part code</span></div><div class="line">    <span class="keyword">else</span> <span class="comment"># call function</span></div><div class="line">        operator = eval(exp[<span class="number">0</span>], env) <span class="comment"># first thing of s-expression sequence.</span></div><div class="line">        operands = exp[<span class="number">1</span>..-<span class="number">1</span>].map &#123;<span class="params">|sub_exp|</span> eval(sub_exp, env) &#125; <span class="comment"># the rest things of sequence</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> operator.is_a? Closure <span class="comment"># compounded procedures(user-defined)# extends environment with parameters and their actual arguments applied.</span></div><div class="line"></div><div class="line">            env_fn = operator.parameters.zip(operands) + operator.env</div><div class="line">            body = operator.body</div><div class="line">            eval(body, env_fn)</div><div class="line">        <span class="keyword">else</span> <span class="comment"># primitive operators</span></div><div class="line">            operator.call *operands</div><div class="line">        <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>另外environment有了较大的改动，之前使用hash结构，在写这篇文章的时候，我重新审查代码时候，发现有较大缺陷：</p>
<ul>
<li>之前hash结构，define定义新变量是直接更改该hash本身，mutation操作。定义lambda的时候，最初直接传入env本身，然而因为hash是可变的，所以实现的是<code>dynamic scope</code>方式，后续对env操作也会影响函数定义是当前的env(就是同一个对象)。</li>
<li>我最初的处理方法是，对于函数定义时候的env，使用一个新的对象<code>env.clone</code>。似乎解决了问题，但是在某些simultaneous同时发生，比如需要两个方法同时定义，如果通过<code>env.clone</code>，两个方法的env是两个独立对象，然而我们需要两个方法env都是同一个对象，因为它们处于并列状态，例如<code>letrec</code>（不是本文重点，但代码中有实现）。</li>
</ul>
<p>所以，需要改变的是：</p>
<ul>
<li>define添加新的variable到当前env（并不改变原先env）作为新的env。相当于新的environment是immutable。</li>
<li>定义lambda的时候，直接使用当前的env。</li>
</ul>
<div class="figure">
<img src="/images/2017-RacketOnRuby/closure-env.jpg" alt="the environment of the closure">
<p class="caption">the environment of the closure</p>
</div>
<p>对应到ruby代码实现。使用array取代hash，其中每个元素即变量和其对应的值（2个元素的array分别存variable,value）。 define时候通过 <code>env[0..-1]</code> 重新赋值env。由于现在需要直接更改当前的environment，而且ruby不支持参数传入引用，所以我使用<code>env[0..-1] = [new array]</code>将env内的array中的元素替换成新的env（包含新定义的variable），来达到更改当前environment目的。</p>
<figure class="highlight ruby"><figcaption><span>new environment\</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@env = [</div><div class="line">    [<span class="symbol">:<span class="string">'#t'</span></span> ,  <span class="literal">true</span>],</div><div class="line">    [<span class="symbol">:<span class="string">'#f'</span></span> ,  <span class="literal">false</span>],</div><div class="line">    <span class="comment"># Racket 'not' operator if exp is #f, results #t. otherwise false. it differents from ruby not</span></div><div class="line">    [<span class="symbol">:not</span> ,  lambda &#123; <span class="params">|exp|</span> <span class="keyword">if</span> <span class="literal">false</span>==exp <span class="keyword">then</span> <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span> <span class="keyword">end</span> &#125;],</div><div class="line">    <span class="comment"># ... other primitive procedures.</span></div><div class="line">    ]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(exp, env=@env)</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lookup_env</span><span class="params">(env, var)</span></span></div><div class="line">        error_no_var = <span class="string">"undefined: %s !"</span> % var</div><div class="line">        var_val = env.assoc var</div><div class="line"></div><div class="line">        <span class="keyword">if</span> var_val.<span class="literal">nil</span>?</div><div class="line">            raise error_no_var</div><div class="line">        <span class="keyword">elsif</span> var_val[<span class="number">1</span>] == UNASSIGNED_VAL</div><div class="line">            raise <span class="string">"the unassigned value should not be access."</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> var_val[<span class="number">1</span>]</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    <span class="comment"># ... other eval parts</span></div><div class="line">    <span class="keyword">elsif</span> exp[<span class="number">0</span>] == <span class="symbol">:define</span></div><div class="line">        <span class="number">_</span>, var, value_exp = exp</div><div class="line"></div><div class="line">        value = eval( value_exp, env )</div><div class="line">        env[<span class="number">0</span>..-<span class="number">1</span>] = [[var , value]] + env</div><div class="line">    <span class="comment"># ... other eval parts</span></div><div class="line"><span class="keyword">end</span> <span class="comment"># eval</span></div></pre></td></tr></table></figure>
<p>至此，最重要的lambda部分就已经完成实现了。</p>
<h2 id="racketonruby总结">RacketOnRuby总结</h2>
<p>出于练习目的，实现Racket的一个解析器。从功能完整性和性能考虑，并不适合实际生产中运用。</p>
<p>得益于Racket语法统一简单，实现也相对简单。不像很多别的语言，有大量不同形式的语法。</p>
<ul>
<li>相对于原生Racket，肯定缺少一些功能，但常见的基本都实现了。
<ul>
<li>实现了environment、variable、condition(if)、 lambda、 cons cells、 list、 一些primitive procedures(代数运算，数值比较)。</li>
<li>语法缺少的：注释<em>comment</em>、 quote、 # symbol(字面量类似Ruby symbol)、 一些derived expression(可以转化为现有的别的表达式，例如cond用来多个条件判断，可以转化为嵌套的if)</li>
<li>项目中代码是实现有<code>let</code>和<code>letrec</code>，也是derived expression。<code>(let ([&lt;var&gt; &lt;exp&gt;]) body)</code>其作用就是绑定local variable，并在其environment执行body部分代码。<code>let</code>可以转为<code>lambda</code>, <code>letrec</code>可以转为一种特殊形式<code>let</code>。转化方法是直接操作AST，由于Ruby中AST用的Array表现，并不是那么清晰，所以不做本文重点。（相对于metalanguage使用Lisp系语言，Lisp系语言code即data，代码部分也可以操作，即可以直接在程序expression上直接操作）</li>
<li>缺少大量primitive procedures，语言肯定会有大量自带的函数，不可能一一实现。其中之一就是mutation list，Racket的默认list是不可变的immutable。如果需要可变的，有专门的操作:<code>mcons</code>，<code>set-mcar!</code>, <code>set-mcdr!</code>。这一点也是Racket与Scheme不同的一处，Scheme中list是mutation list。</li>
<li>error handling不是主要目标，所以几乎没有异常错误处理，所以需要执行的program先要保证正确的。可以DrRacket先执行一遍，尤其括号方面（多或者少，不匹配），IDE可以很明显看出括号范围。</li>
</ul></li>
<li>性能方面，也不是主要目标，没有特别优化。下面指出一些可以改进的地方：
<ul>
<li><p><code>eval</code>实现，实际上语义分析<em>syntactic analysis</em>夹杂在执行<em>execution</em>之中，不是有效率的做法。如下阶乘的program，当执行<code>(factorial 5)</code>，递归调用<code>factorial</code>多次，其中<code>if</code>部分每次都需要判断出是<code>if</code>，但执行到<code>(* (factorial (- n 1)) n)))</code>其中<code>(- n 1)</code>和<code>(factorial (- n 1))</code>都需要在<code>eval</code>判断出是方法执行然后再处理。非常重复浪费的做法，需要将analysis分离出来，本文并没涉及，具体实现可以参考SICP<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>第四大章中<em>Separating Syntactic Analysis from Execution</em>小节部分 <figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial</span> n)</div><div class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>)</div><div class="line">        <span class="number">1</span></div><div class="line">        (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)) n)))</div></pre></td></tr></table></figure></p></li>
<li><p>缺少<code>TCO</code><em>tail call optimization</em>，尾递归优化，Lisp和Scheme系的语言program非常依赖与递归调用，TCO非常重要，能省去很多function call占用的stack空间。</p></li>
</ul></li>
</ul>
<p>要想了解interpreter如何工作，最好办法就是自己实现一个了，这就是我实现RacketOnRuby以及写本文的目的。 如果需要更深入了解，推荐上文提及SICP以及另外一本书TSPL<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>，都是有免费阅读的电子版。或者自行搜索，有相当多的资料。</p>
<p>另外文章最开始提及的《黑客与画家》，非编程技术书，也推荐阅读。语言通俗易懂，不涉及技术细节，阅读不费力，非程序员也能读。但其中作者的思想条理清晰，观点深入透彻。另外本书也不光全是关于Lisp，还有一些有趣事情，我印象较深的就是最开始的章节“为什么书呆子不受欢迎”。</p>
<!-- toc -->
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://ruby-doc.org/core-2.4.0/String.html#method-i-split" target="_blank" rel="external">Ruby Doc: String.split</a>: If pattern is a String, then its contents are used as the delimiter when splitting str. If pattern is <strong>a single space</strong>, str is split on <strong>whitespace</strong>, with leading whitespace and runs of <strong>contiguous whitespace characters ignored</strong>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="https://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-each_cons" target="_blank" rel="external">Ruby Doc Enumerable each_cons(n)</a>: Iterates the given block for each array of consecutive <n> elements. If no block is given, returns an enumerator.<a href="#fnref2">↩</a></n></p></li>
<li id="fn3"><p><em>Structure and Interpretation of Computer Programs</em> <a href="https://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank" rel="external">MIT scheme课程书籍</a>.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><em>The Scheme Programming Language</em> <a href="http://www.scheme.com/tspl4/" class="uri" target="_blank" rel="external">http://www.scheme.com/tspl4/</a>.<a href="#fnref4">↩</a></p></li>
</ol>
</div>

    
  </section>


  <footer class="article-footer">

    
        <hr class="article-hr"/><div class="creative-commons">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">
        <img alt="知识共享许可协议" style="border-width:0"
            src="/images/creative-commons/BY-NC-ND.png" />
    </a>
    
    <br />本作品采用
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">
        知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议
    </a>进行许可。
</div>

        <hr class="article-hr"/>
    
  <div class="article-tag">
    <label class="article-tag-label" for="">标签: </label><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/eval/">eval</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interpreter/">interpreter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lambda/">lambda</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lisp/">lisp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/racket/">racket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ruby/">ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scheme/">scheme</a></li></ul>
  </div>


    
  <hr class="article-hr"/>
  <nav id="article-nav">
    
      <a class="article-nav-link prev" href="/2017/04/01/blender-cycles-render-donuts/">
        <span class="article-nav-caption">前一篇: </span>
        
          Blender Cycles渲染作品 面包圈
        
      </a>
    
    
      <a class="article-nav-link next" href="/2017/02/17/UE4-work-book-room/">
        <span class="article-nav-caption">后一篇: </span>
        
          UE4作品 简易书房
        
      </a>
    
  </nav>


    
  </footer>



  <section id="comments">
      <div id="disqus_thread"></div>
      <script>

          /**
          *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
          *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

          var disqus_config = function () {
              this.page.url = "http://www.mix-flow.com/2017/02/20/write-racket-scheme-interpreter-on-ruby/";  // Replace PAGE_URL with your page's canonical URL variable
              this.page.identifier = "post-write-racket-scheme-interpreter-on-ruby"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
          };

          (function() { // DON'T EDIT BELOW THIS LINE
          var d = document, s = d.createElement('script');
          s.src = 'https://mixflow.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
      })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </section>

</article>


    <footer>
    <p>©2017 MixFlow</p>
    <p>
        Theme by MixFlow |
        Power by <a href="https://hexo.io">Hexo</a>
    </p>
</footer>

      </div>
    
  </body>
</html>
